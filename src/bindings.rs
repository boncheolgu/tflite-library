#![allow(dead_code, clippy::all)]

pub use self::root::*;

include!(concat!(env!("OUT_DIR"), "/tflite_types.rs"));
#[cfg(never)]
mod testing {
    /* automatically generated by rust-bindgen 0.58.1 */

    #[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
    pub mod root {
        #[repr(C)]
        #[derive(Default)]
        pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);

        impl<T> __IncompleteArrayField<T> {
            #[inline]
            pub const fn new() -> Self {
                __IncompleteArrayField(::std::marker::PhantomData, [])
            }
            #[inline]
            pub fn as_ptr(&self) -> *const T {
                self as *const _ as *const T
            }
            #[inline]
            pub fn as_mut_ptr(&mut self) -> *mut T {
                self as *mut _ as *mut T
            }
            #[inline]
            pub unsafe fn as_slice(&self, len: usize) -> &[T] {
                ::std::slice::from_raw_parts(self.as_ptr(), len)
            }
            #[inline]
            pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
                ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
            }
        }

        impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
            fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                fmt.write_str("__IncompleteArrayField")
            }
        }

        #[allow(unused_imports)]
        use self::super::root;

        pub mod std {
            #[allow(unused_imports)]
            use self::super::super::root;

            pub type string = [u64; 4usize];
            pub type integral_constant_value_type<_Tp> = _Tp;
            pub type integral_constant_type = u8;
            pub type true_type = u8;
            pub type false_type = u8;

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct __and_ {
                pub _address: u8,
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct is_empty {
                pub _address: u8,
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct make_unsigned {
                pub _address: u8,
            }

            pub type make_unsigned_type = u8;

            #[repr(C)]
            #[derive(Copy, Clone)]
            pub union aligned_storage_type {
                pub __data: *mut ::std::os::raw::c_uchar,
                pub __align: root::std::aligned_storage_type__bindgen_ty_1,
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct aligned_storage_type__bindgen_ty_1 {
                pub _address: u8,
            }

            #[test]
            fn bindgen_test_layout_aligned_storage_type() {
                assert_eq!(
                    ::std::mem::size_of::<aligned_storage_type>(),
                    8usize,
                    concat!("Size of: ", stringify!(aligned_storage_type))
                );
                assert_eq!(
                    ::std::mem::align_of::<aligned_storage_type>(),
                    8usize,
                    concat!("Alignment of ", stringify!(aligned_storage_type))
                );
            }

            impl Default for aligned_storage_type {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            impl ::std::fmt::Debug for aligned_storage_type {
                fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                    write!(f, "aligned_storage_type {{ union }}")
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct __detector {
                pub _address: u8,
            }

            pub type __detector_value_t = root::std::false_type;
            pub type __detector_type<_Default> = _Default;
            pub type __detected_or = root::std::__detector;
            pub type __detected_or_t = root::std::__detected_or;

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct iterator {
                pub _address: u8,
            }

            pub type iterator_iterator_category<_Category> = _Category;
            pub type iterator_value_type<_Tp> = _Tp;
            pub type iterator_difference_type<_Distance> = _Distance;
            pub type iterator_pointer<_Pointer> = _Pointer;
            pub type iterator_reference<_Reference> = _Reference;

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct __iterator_traits {
                pub _address: u8,
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct iterator_traits {
                pub _address: u8,
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct __undefined {
                _unused: [u8; 0],
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct __get_first_arg {
                pub _address: u8,
            }

            pub type __get_first_arg_type = root::std::__undefined;
            pub type __get_first_arg_t = root::std::__get_first_arg;

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct __replace_first_arg {
                pub _address: u8,
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct pointer_traits {
                pub _address: u8,
            }

            pub type pointer_traits___element_type = [u8; 0usize];
            pub type pointer_traits___difference_type = [u8; 0usize];

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct pointer_traits___rebind {
                pub _address: u8,
            }

            impl Default for pointer_traits___rebind {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            pub type pointer_traits_pointer<_Ptr> = _Ptr;
            pub type pointer_traits_element_type = root::std::__detected_or_t;
            pub type pointer_traits_difference_type = root::std::__detected_or_t;
            pub type pointer_traits_rebind = root::std::pointer_traits___rebind;

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct reverse_iterator<_Iterator> {
                pub current: _Iterator,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
            }

            pub type reverse_iterator___traits_type = root::std::iterator_traits;
            pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
            pub type reverse_iterator_difference_type = root::std::reverse_iterator___traits_type;
            pub type reverse_iterator_pointer = root::std::reverse_iterator___traits_type;
            pub type reverse_iterator_reference = root::std::reverse_iterator___traits_type;

            impl<_Iterator> Default for reverse_iterator<_Iterator> {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            pub type __allocator_base = root::__gnu_cxx::new_allocator;

            #[repr(C)]
            #[derive(Debug, PartialEq, Eq)]
            pub struct allocator {
                pub _address: u8,
            }

            pub type allocator_size_type = usize;
            pub type allocator_difference_type = isize;
            pub type allocator_pointer<_Tp> = *mut _Tp;
            pub type allocator_const_pointer<_Tp> = *const _Tp;
            pub type allocator_reference<_Tp> = *mut _Tp;
            pub type allocator_const_reference<_Tp> = *const _Tp;
            pub type allocator_value_type<_Tp> = _Tp;

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct allocator_rebind {
                pub _address: u8,
            }

            pub type allocator_rebind_other = root::std::allocator;
            pub type allocator_propagate_on_container_move_assignment = root::std::true_type;
            pub type allocator_is_always_equal = root::std::true_type;

            impl Default for allocator {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct __allocator_traits_base {
                pub _address: u8,
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct __allocator_traits_base___rebind {
                pub _address: u8,
            }

            impl Default for __allocator_traits_base___rebind {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            pub type __allocator_traits_base___pointer = [u8; 0usize];
            pub type __allocator_traits_base___c_pointer = [u8; 0usize];
            pub type __allocator_traits_base___v_pointer = [u8; 0usize];
            pub type __allocator_traits_base___cv_pointer = [u8; 0usize];
            pub type __allocator_traits_base___pocca = [u8; 0usize];
            pub type __allocator_traits_base___pocma = [u8; 0usize];
            pub type __allocator_traits_base___pocs = [u8; 0usize];
            pub type __allocator_traits_base___equal = [u8; 0usize];

            #[test]
            fn bindgen_test_layout___allocator_traits_base() {
                assert_eq!(
                    ::std::mem::size_of::<__allocator_traits_base>(),
                    1usize,
                    concat!("Size of: ", stringify!(__allocator_traits_base))
                );
                assert_eq!(
                    ::std::mem::align_of::<__allocator_traits_base>(),
                    1usize,
                    concat!("Alignment of ", stringify!(__allocator_traits_base))
                );
            }

            pub type __alloc_rebind = root::std::__allocator_traits_base;

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct allocator_traits {
                pub _address: u8,
            }

            pub type allocator_traits_allocator_type<_Alloc> = _Alloc;
            pub type allocator_traits_value_type = [u8; 0usize];
            pub type allocator_traits_pointer = root::std::__detected_or_t;

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct allocator_traits__Ptr {
                pub _address: u8,
            }

            pub type allocator_traits__Ptr_type = [u8; 0usize];

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct allocator_traits__Diff {
                pub _address: u8,
            }

            pub type allocator_traits__Diff_type = root::std::pointer_traits;

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct allocator_traits__Size {
                pub _address: u8,
            }

            impl Default for allocator_traits__Size {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            pub type allocator_traits_const_pointer = [u8; 0usize];
            pub type allocator_traits_void_pointer = root::std::allocator_traits__Ptr;
            pub type allocator_traits_const_void_pointer = root::std::allocator_traits__Ptr;
            pub type allocator_traits_difference_type = [u8; 0usize];
            pub type allocator_traits_size_type = [u8; 0usize];
            pub type allocator_traits_propagate_on_container_copy_assignment =
                root::std::__detected_or_t;
            pub type allocator_traits_propagate_on_container_move_assignment =
                root::std::__detected_or_t;
            pub type allocator_traits_propagate_on_container_swap = root::std::__detected_or_t;
            pub type allocator_traits_is_always_equal = root::std::__detected_or_t;
            pub type allocator_traits_rebind_alloc = root::std::__alloc_rebind;
            pub type allocator_traits_rebind_traits = root::std::allocator_traits;

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct allocator_traits___construct_helper {
                pub _address: u8,
            }

            pub type allocator_traits___construct_helper_type<_Alloc> = _Alloc;
            pub type allocator_traits___has_construct =
                root::std::allocator_traits___construct_helper;

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct tuple {
                pub _address: usize,
            }

            pub type tuple__Inherited = u8;

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct tuple__TC2 {
                pub _address: u8,
            }

            pub type tuple__TCC = u8;
            pub type tuple__TMC = u8;
            pub type tuple__TMCT = u8;
            pub type tuple__TNTC = u8;

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct default_delete {
                pub _address: u8,
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct __uniq_ptr_impl {
                pub _M_t: root::std::tuple,
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct __uniq_ptr_impl__Ptr {
                pub _address: u8,
            }

            pub type __uniq_ptr_impl__Ptr_type<_Up> = *mut _Up;
            pub type __uniq_ptr_impl__DeleterConstraint = u8;
            pub type __uniq_ptr_impl_pointer = root::std::__uniq_ptr_impl__Ptr;

            #[repr(C)]
            #[derive(Debug, PartialEq, Eq)]
            pub struct unique_ptr {
                pub _M_t: root::std::__uniq_ptr_impl,
            }

            pub type unique_ptr__DeleterConstraint = root::std::__uniq_ptr_impl;
            pub type unique_ptr_pointer = root::std::__uniq_ptr_impl;
            pub type unique_ptr_element_type<_Tp> = _Tp;
            pub type unique_ptr_deleter_type<_Dp> = _Dp;
            pub type unique_ptr___safe_conversion_up = root::std::__and_;

            impl Default for unique_ptr {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, PartialEq, Eq)]
            pub struct _Vector_base {
                pub _M_impl: root::std::_Vector_base__Vector_impl,
            }

            pub type _Vector_base__Tp_alloc_type = root::__gnu_cxx::__alloc_traits;
            pub type _Vector_base_pointer = root::__gnu_cxx::__alloc_traits;

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct _Vector_base__Vector_impl {
                pub _M_start: root::std::_Vector_base_pointer,
                pub _M_finish: root::std::_Vector_base_pointer,
                pub _M_end_of_storage: root::std::_Vector_base_pointer,
            }

            impl Default for _Vector_base__Vector_impl {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            pub type _Vector_base_allocator_type<_Alloc> = _Alloc;

            impl Default for _Vector_base {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, PartialEq, Eq)]
            pub struct vector {
                pub _base: root::std::_Vector_base,
            }

            pub type vector__Base = root::std::_Vector_base;
            pub type vector__Tp_alloc_type = root::std::vector__Base;
            pub type vector__Alloc_traits = root::__gnu_cxx::__alloc_traits;
            pub type vector_value_type<_Tp> = _Tp;
            pub type vector_pointer = root::std::vector__Base;
            pub type vector_const_pointer = root::std::vector__Alloc_traits;
            pub type vector_reference = root::std::vector__Alloc_traits;
            pub type vector_const_reference = root::std::vector__Alloc_traits;
            pub type vector_iterator =
                root::__gnu_cxx::__normal_iterator<root::std::vector_pointer>;
            pub type vector_const_iterator =
                root::__gnu_cxx::__normal_iterator<root::std::vector_const_pointer>;
            pub type vector_const_reverse_iterator =
                root::std::reverse_iterator<root::std::vector_const_iterator>;
            pub type vector_reverse_iterator =
                root::std::reverse_iterator<root::std::vector_iterator>;
            pub type vector_size_type = usize;
            pub type vector_difference_type = isize;
            pub type vector_allocator_type<_Alloc> = _Alloc;

            #[repr(C)]
            #[derive(Debug, PartialEq, Eq)]
            pub struct vector__Temporary_value {
                pub _M_this: *mut root::std::vector,
                pub __buf: u8,
            }

            impl Default for vector__Temporary_value {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            impl Default for vector {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
        }

        pub mod __gnu_cxx {
            #[allow(unused_imports)]
            use self::super::super::root;

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct __normal_iterator<_Iterator> {
                pub _M_current: _Iterator,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
            }

            pub type __normal_iterator___traits_type = root::std::iterator_traits;
            pub type __normal_iterator_iterator_type<_Iterator> = _Iterator;
            pub type __normal_iterator_iterator_category =
                root::__gnu_cxx::__normal_iterator___traits_type;
            pub type __normal_iterator_value_type =
                root::__gnu_cxx::__normal_iterator___traits_type;
            pub type __normal_iterator_difference_type =
                root::__gnu_cxx::__normal_iterator___traits_type;
            pub type __normal_iterator_reference = root::__gnu_cxx::__normal_iterator___traits_type;
            pub type __normal_iterator_pointer = root::__gnu_cxx::__normal_iterator___traits_type;

            impl<_Iterator> Default for __normal_iterator<_Iterator> {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, PartialEq, Eq)]
            pub struct new_allocator {
                pub _address: u8,
            }

            pub type new_allocator_size_type = usize;
            pub type new_allocator_difference_type = isize;
            pub type new_allocator_pointer<_Tp> = *mut _Tp;
            pub type new_allocator_const_pointer<_Tp> = *const _Tp;
            pub type new_allocator_reference<_Tp> = *mut _Tp;
            pub type new_allocator_const_reference<_Tp> = *const _Tp;
            pub type new_allocator_value_type<_Tp> = _Tp;

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct new_allocator_rebind {
                pub _address: u8,
            }

            pub type new_allocator_rebind_other = root::__gnu_cxx::new_allocator;
            pub type new_allocator_propagate_on_container_move_assignment = root::std::true_type;

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct __alloc_traits {
                pub _address: usize,
            }

            pub type __alloc_traits_allocator_type<_Alloc> = _Alloc;
            pub type __alloc_traits__Base_type = root::std::allocator_traits;
            pub type __alloc_traits_value_type = root::__gnu_cxx::__alloc_traits__Base_type;
            pub type __alloc_traits_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
            pub type __alloc_traits_const_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
            pub type __alloc_traits_size_type = root::__gnu_cxx::__alloc_traits__Base_type;
            pub type __alloc_traits_difference_type = root::__gnu_cxx::__alloc_traits__Base_type;
            pub type __alloc_traits_reference = *mut root::__gnu_cxx::__alloc_traits_value_type;
            pub type __alloc_traits_const_reference =
                *const root::__gnu_cxx::__alloc_traits_value_type;
            pub type __alloc_traits___is_custom_pointer = root::std::__and_;

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct __alloc_traits_rebind {
                pub _address: u8,
            }

            pub type __alloc_traits_rebind_other = root::__gnu_cxx::__alloc_traits__Base_type;

            impl Default for __alloc_traits {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }
        }

        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TfLiteStatus {
            kTfLiteOk = 0,
            kTfLiteError = 1,
            kTfLiteDelegateError = 2,
            kTfLiteApplicationError = 3,
        }

        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TfLiteExternalContextType {
            kTfLiteEigenContext = 0,
            kTfLiteGemmLowpContext = 1,
            kTfLiteEdgeTpuContext = 2,
            kTfLiteCpuBackendContext = 3,
            kTfLiteMaxExternalContexts = 4,
        }

        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct TfLiteExternalContext {
            pub type_: root::TfLiteExternalContextType,
            pub Refresh: ::std::option::Option<
                unsafe extern "C" fn(context: *mut root::TfLiteContext) -> root::TfLiteStatus,
            >,
        }

        #[test]
        fn bindgen_test_layout_TfLiteExternalContext() {
            assert_eq!(
                ::std::mem::size_of::<TfLiteExternalContext>(),
                16usize,
                concat!("Size of: ", stringify!(TfLiteExternalContext))
            );
            assert_eq!(
                ::std::mem::align_of::<TfLiteExternalContext>(),
                8usize,
                concat!("Alignment of ", stringify!(TfLiteExternalContext))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteExternalContext>())).type_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteExternalContext),
                    "::",
                    stringify!(type_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteExternalContext>())).Refresh as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteExternalContext),
                    "::",
                    stringify!(Refresh)
                )
            );
        }

        impl Default for TfLiteExternalContext {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }

        #[repr(C)]
        #[derive(Debug, Default)]
        pub struct TfLiteIntArray {
            pub size: ::std::os::raw::c_int,
            pub data: root::__IncompleteArrayField<::std::os::raw::c_int>,
        }

        #[test]
        fn bindgen_test_layout_TfLiteIntArray() {
            assert_eq!(
                ::std::mem::size_of::<TfLiteIntArray>(),
                4usize,
                concat!("Size of: ", stringify!(TfLiteIntArray))
            );
            assert_eq!(
                ::std::mem::align_of::<TfLiteIntArray>(),
                4usize,
                concat!("Alignment of ", stringify!(TfLiteIntArray))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteIntArray>())).size as *const _ as usize },
                0usize,
                concat!("Offset of field: ", stringify!(TfLiteIntArray), "::", stringify!(size))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteIntArray>())).data as *const _ as usize },
                4usize,
                concat!("Offset of field: ", stringify!(TfLiteIntArray), "::", stringify!(data))
            );
        }

        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq)]
        pub struct TfLiteComplex64 {
            pub re: f32,
            pub im: f32,
        }

        #[test]
        fn bindgen_test_layout_TfLiteComplex64() {
            assert_eq!(
                ::std::mem::size_of::<TfLiteComplex64>(),
                8usize,
                concat!("Size of: ", stringify!(TfLiteComplex64))
            );
            assert_eq!(
                ::std::mem::align_of::<TfLiteComplex64>(),
                4usize,
                concat!("Alignment of ", stringify!(TfLiteComplex64))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteComplex64>())).re as *const _ as usize },
                0usize,
                concat!("Offset of field: ", stringify!(TfLiteComplex64), "::", stringify!(re))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteComplex64>())).im as *const _ as usize },
                4usize,
                concat!("Offset of field: ", stringify!(TfLiteComplex64), "::", stringify!(im))
            );
        }

        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq)]
        pub struct TfLiteComplex128 {
            pub re: f64,
            pub im: f64,
        }

        #[test]
        fn bindgen_test_layout_TfLiteComplex128() {
            assert_eq!(
                ::std::mem::size_of::<TfLiteComplex128>(),
                16usize,
                concat!("Size of: ", stringify!(TfLiteComplex128))
            );
            assert_eq!(
                ::std::mem::align_of::<TfLiteComplex128>(),
                8usize,
                concat!("Alignment of ", stringify!(TfLiteComplex128))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteComplex128>())).re as *const _ as usize },
                0usize,
                concat!("Offset of field: ", stringify!(TfLiteComplex128), "::", stringify!(re))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteComplex128>())).im as *const _ as usize },
                8usize,
                concat!("Offset of field: ", stringify!(TfLiteComplex128), "::", stringify!(im))
            );
        }

        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
        pub struct TfLiteFloat16 {
            pub data: u16,
        }

        #[test]
        fn bindgen_test_layout_TfLiteFloat16() {
            assert_eq!(
                ::std::mem::size_of::<TfLiteFloat16>(),
                2usize,
                concat!("Size of: ", stringify!(TfLiteFloat16))
            );
            assert_eq!(
                ::std::mem::align_of::<TfLiteFloat16>(),
                2usize,
                concat!("Alignment of ", stringify!(TfLiteFloat16))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteFloat16>())).data as *const _ as usize },
                0usize,
                concat!("Offset of field: ", stringify!(TfLiteFloat16), "::", stringify!(data))
            );
        }

        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TfLiteType {
            kTfLiteNoType = 0,
            kTfLiteFloat32 = 1,
            kTfLiteInt32 = 2,
            kTfLiteUInt8 = 3,
            kTfLiteInt64 = 4,
            kTfLiteString = 5,
            kTfLiteBool = 6,
            kTfLiteInt16 = 7,
            kTfLiteComplex64 = 8,
            kTfLiteInt8 = 9,
            kTfLiteFloat16 = 10,
            kTfLiteFloat64 = 11,
            kTfLiteComplex128 = 12,
        }

        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TfLiteQuantizationType {
            kTfLiteNoQuantization = 0,
            kTfLiteAffineQuantization = 1,
        }

        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct TfLiteQuantization {
            pub type_: root::TfLiteQuantizationType,
            pub params: *mut ::std::os::raw::c_void,
        }

        #[test]
        fn bindgen_test_layout_TfLiteQuantization() {
            assert_eq!(
                ::std::mem::size_of::<TfLiteQuantization>(),
                16usize,
                concat!("Size of: ", stringify!(TfLiteQuantization))
            );
            assert_eq!(
                ::std::mem::align_of::<TfLiteQuantization>(),
                8usize,
                concat!("Alignment of ", stringify!(TfLiteQuantization))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteQuantization>())).type_ as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteQuantization),
                    "::",
                    stringify!(type_)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteQuantization>())).params as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteQuantization),
                    "::",
                    stringify!(params)
                )
            );
        }

        impl Default for TfLiteQuantization {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }

        #[repr(C)]
        #[derive(Debug, Default, Copy, Clone, PartialEq)]
        pub struct TfLiteQuantizationParams {
            pub scale: f32,
            pub zero_point: i32,
        }

        #[test]
        fn bindgen_test_layout_TfLiteQuantizationParams() {
            assert_eq!(
                ::std::mem::size_of::<TfLiteQuantizationParams>(),
                8usize,
                concat!("Size of: ", stringify!(TfLiteQuantizationParams))
            );
            assert_eq!(
                ::std::mem::align_of::<TfLiteQuantizationParams>(),
                4usize,
                concat!("Alignment of ", stringify!(TfLiteQuantizationParams))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteQuantizationParams>())).scale as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteQuantizationParams),
                    "::",
                    stringify!(scale)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteQuantizationParams>())).zero_point as *const _
                        as usize
                },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteQuantizationParams),
                    "::",
                    stringify!(zero_point)
                )
            );
        }

        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union TfLitePtrUnion {
            pub i32_: *mut i32,
            pub i64_: *mut i64,
            pub f: *mut f32,
            pub f16: *mut root::TfLiteFloat16,
            pub f64_: *mut f64,
            pub raw: *mut ::std::os::raw::c_char,
            pub raw_const: *const ::std::os::raw::c_char,
            pub uint8: *mut u8,
            pub b: *mut bool,
            pub i16_: *mut i16,
            pub c64: *mut root::TfLiteComplex64,
            pub c128: *mut root::TfLiteComplex128,
            pub int8: *mut i8,
            pub data: *mut ::std::os::raw::c_void,
        }

        #[test]
        fn bindgen_test_layout_TfLitePtrUnion() {
            assert_eq!(
                ::std::mem::size_of::<TfLitePtrUnion>(),
                8usize,
                concat!("Size of: ", stringify!(TfLitePtrUnion))
            );
            assert_eq!(
                ::std::mem::align_of::<TfLitePtrUnion>(),
                8usize,
                concat!("Alignment of ", stringify!(TfLitePtrUnion))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).i32_ as *const _ as usize },
                0usize,
                concat!("Offset of field: ", stringify!(TfLitePtrUnion), "::", stringify!(i32_))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).i64_ as *const _ as usize },
                0usize,
                concat!("Offset of field: ", stringify!(TfLitePtrUnion), "::", stringify!(i64_))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).f as *const _ as usize },
                0usize,
                concat!("Offset of field: ", stringify!(TfLitePtrUnion), "::", stringify!(f))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).f16 as *const _ as usize },
                0usize,
                concat!("Offset of field: ", stringify!(TfLitePtrUnion), "::", stringify!(f16))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).f64_ as *const _ as usize },
                0usize,
                concat!("Offset of field: ", stringify!(TfLitePtrUnion), "::", stringify!(f64_))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).raw as *const _ as usize },
                0usize,
                concat!("Offset of field: ", stringify!(TfLitePtrUnion), "::", stringify!(raw))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLitePtrUnion>())).raw_const as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLitePtrUnion),
                    "::",
                    stringify!(raw_const)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).uint8 as *const _ as usize },
                0usize,
                concat!("Offset of field: ", stringify!(TfLitePtrUnion), "::", stringify!(uint8))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).b as *const _ as usize },
                0usize,
                concat!("Offset of field: ", stringify!(TfLitePtrUnion), "::", stringify!(b))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).i16_ as *const _ as usize },
                0usize,
                concat!("Offset of field: ", stringify!(TfLitePtrUnion), "::", stringify!(i16_))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).c64 as *const _ as usize },
                0usize,
                concat!("Offset of field: ", stringify!(TfLitePtrUnion), "::", stringify!(c64))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).c128 as *const _ as usize },
                0usize,
                concat!("Offset of field: ", stringify!(TfLitePtrUnion), "::", stringify!(c128))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).int8 as *const _ as usize },
                0usize,
                concat!("Offset of field: ", stringify!(TfLitePtrUnion), "::", stringify!(int8))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).data as *const _ as usize },
                0usize,
                concat!("Offset of field: ", stringify!(TfLitePtrUnion), "::", stringify!(data))
            );
        }

        impl Default for TfLitePtrUnion {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }

        impl ::std::fmt::Debug for TfLitePtrUnion {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "TfLitePtrUnion {{ union }}")
            }
        }

        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TfLiteAllocationType {
            kTfLiteMemNone = 0,
            kTfLiteMmapRo = 1,
            kTfLiteArenaRw = 2,
            kTfLiteArenaRwPersistent = 3,
            kTfLiteDynamic = 4,
            kTfLitePersistentRo = 5,
            kTfLiteCustom = 6,
        }

        pub type TfLiteBufferHandle = ::std::os::raw::c_int;

        #[repr(u32)]
        #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
        pub enum TfLiteDimensionType {
            kTfLiteDimDense = 0,
            kTfLiteDimSparseCSR = 1,
        }

        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct TfLiteDimensionMetadata {
            pub format: root::TfLiteDimensionType,
            pub dense_size: ::std::os::raw::c_int,
            pub array_segments: *mut root::TfLiteIntArray,
            pub array_indices: *mut root::TfLiteIntArray,
        }

        #[test]
        fn bindgen_test_layout_TfLiteDimensionMetadata() {
            assert_eq!(
                ::std::mem::size_of::<TfLiteDimensionMetadata>(),
                24usize,
                concat!("Size of: ", stringify!(TfLiteDimensionMetadata))
            );
            assert_eq!(
                ::std::mem::align_of::<TfLiteDimensionMetadata>(),
                8usize,
                concat!("Alignment of ", stringify!(TfLiteDimensionMetadata))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteDimensionMetadata>())).format as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteDimensionMetadata),
                    "::",
                    stringify!(format)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteDimensionMetadata>())).dense_size as *const _
                        as usize
                },
                4usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteDimensionMetadata),
                    "::",
                    stringify!(dense_size)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteDimensionMetadata>())).array_segments as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteDimensionMetadata),
                    "::",
                    stringify!(array_segments)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteDimensionMetadata>())).array_indices as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteDimensionMetadata),
                    "::",
                    stringify!(array_indices)
                )
            );
        }

        impl Default for TfLiteDimensionMetadata {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }

        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct TfLiteSparsity {
            pub traversal_order: *mut root::TfLiteIntArray,
            pub block_map: *mut root::TfLiteIntArray,
            pub dim_metadata: *mut root::TfLiteDimensionMetadata,
            pub dim_metadata_size: ::std::os::raw::c_int,
        }

        #[test]
        fn bindgen_test_layout_TfLiteSparsity() {
            assert_eq!(
                ::std::mem::size_of::<TfLiteSparsity>(),
                32usize,
                concat!("Size of: ", stringify!(TfLiteSparsity))
            );
            assert_eq!(
                ::std::mem::align_of::<TfLiteSparsity>(),
                8usize,
                concat!("Alignment of ", stringify!(TfLiteSparsity))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteSparsity>())).traversal_order as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteSparsity),
                    "::",
                    stringify!(traversal_order)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteSparsity>())).block_map as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteSparsity),
                    "::",
                    stringify!(block_map)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteSparsity>())).dim_metadata as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteSparsity),
                    "::",
                    stringify!(dim_metadata)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteSparsity>())).dim_metadata_size as *const _
                        as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteSparsity),
                    "::",
                    stringify!(dim_metadata_size)
                )
            );
        }

        impl Default for TfLiteSparsity {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }

        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct TfLiteTensor {
            pub type_: root::TfLiteType,
            pub data: root::TfLitePtrUnion,
            pub dims: *mut root::TfLiteIntArray,
            pub params: root::TfLiteQuantizationParams,
            pub allocation_type: root::TfLiteAllocationType,
            pub bytes: usize,
            pub allocation: *const ::std::os::raw::c_void,
            pub name: *const ::std::os::raw::c_char,
            pub delegate: *mut root::TfLiteDelegate,
            pub buffer_handle: root::TfLiteBufferHandle,
            pub data_is_stale: bool,
            pub is_variable: bool,
            pub quantization: root::TfLiteQuantization,
            pub sparsity: *mut root::TfLiteSparsity,
            pub dims_signature: *const root::TfLiteIntArray,
        }

        #[test]
        fn bindgen_test_layout_TfLiteTensor() {
            assert_eq!(
                ::std::mem::size_of::<TfLiteTensor>(),
                112usize,
                concat!("Size of: ", stringify!(TfLiteTensor))
            );
            assert_eq!(
                ::std::mem::align_of::<TfLiteTensor>(),
                8usize,
                concat!("Alignment of ", stringify!(TfLiteTensor))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).type_ as *const _ as usize },
                0usize,
                concat!("Offset of field: ", stringify!(TfLiteTensor), "::", stringify!(type_))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).data as *const _ as usize },
                8usize,
                concat!("Offset of field: ", stringify!(TfLiteTensor), "::", stringify!(data))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).dims as *const _ as usize },
                16usize,
                concat!("Offset of field: ", stringify!(TfLiteTensor), "::", stringify!(dims))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).params as *const _ as usize },
                24usize,
                concat!("Offset of field: ", stringify!(TfLiteTensor), "::", stringify!(params))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteTensor>())).allocation_type as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteTensor),
                    "::",
                    stringify!(allocation_type)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).bytes as *const _ as usize },
                40usize,
                concat!("Offset of field: ", stringify!(TfLiteTensor), "::", stringify!(bytes))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).allocation as *const _ as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteTensor),
                    "::",
                    stringify!(allocation)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).name as *const _ as usize },
                56usize,
                concat!("Offset of field: ", stringify!(TfLiteTensor), "::", stringify!(name))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).delegate as *const _ as usize },
                64usize,
                concat!("Offset of field: ", stringify!(TfLiteTensor), "::", stringify!(delegate))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteTensor>())).buffer_handle as *const _ as usize
                },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteTensor),
                    "::",
                    stringify!(buffer_handle)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteTensor>())).data_is_stale as *const _ as usize
                },
                76usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteTensor),
                    "::",
                    stringify!(data_is_stale)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteTensor>())).is_variable as *const _ as usize
                },
                77usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteTensor),
                    "::",
                    stringify!(is_variable)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteTensor>())).quantization as *const _ as usize
                },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteTensor),
                    "::",
                    stringify!(quantization)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).sparsity as *const _ as usize },
                96usize,
                concat!("Offset of field: ", stringify!(TfLiteTensor), "::", stringify!(sparsity))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteTensor>())).dims_signature as *const _ as usize
                },
                104usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteTensor),
                    "::",
                    stringify!(dims_signature)
                )
            );
        }

        impl Default for TfLiteTensor {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }

        impl ::std::fmt::Debug for TfLiteTensor {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "TfLiteTensor {{ type: {:?}, data: {:?}, dims: {:?}, params: {:?}, allocation_type: {:?}, bytes: {:?}, allocation: {:?}, name: {:?}, delegate: {:?}, buffer_handle: {:?}, data_is_stale: {:?}, is_variable: {:?}, quantization: {:?}, sparsity: {:?}, dims_signature: {:?} }}", self.type_, self.data, self.dims, self.params, self.allocation_type, self.bytes, self.allocation, self.name, self.delegate, self.buffer_handle, self.data_is_stale, self.is_variable, self.quantization, self.sparsity, self.dims_signature)
            }
        }

        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct TfLiteNode {
            pub inputs: *mut root::TfLiteIntArray,
            pub outputs: *mut root::TfLiteIntArray,
            pub intermediates: *mut root::TfLiteIntArray,
            pub temporaries: *mut root::TfLiteIntArray,
            pub user_data: *mut ::std::os::raw::c_void,
            pub builtin_data: *mut ::std::os::raw::c_void,
            pub custom_initial_data: *const ::std::os::raw::c_void,
            pub custom_initial_data_size: ::std::os::raw::c_int,
            pub delegate: *mut root::TfLiteDelegate,
        }

        #[test]
        fn bindgen_test_layout_TfLiteNode() {
            assert_eq!(
                ::std::mem::size_of::<TfLiteNode>(),
                72usize,
                concat!("Size of: ", stringify!(TfLiteNode))
            );
            assert_eq!(
                ::std::mem::align_of::<TfLiteNode>(),
                8usize,
                concat!("Alignment of ", stringify!(TfLiteNode))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteNode>())).inputs as *const _ as usize },
                0usize,
                concat!("Offset of field: ", stringify!(TfLiteNode), "::", stringify!(inputs))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteNode>())).outputs as *const _ as usize },
                8usize,
                concat!("Offset of field: ", stringify!(TfLiteNode), "::", stringify!(outputs))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteNode>())).intermediates as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteNode),
                    "::",
                    stringify!(intermediates)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteNode>())).temporaries as *const _ as usize },
                24usize,
                concat!("Offset of field: ", stringify!(TfLiteNode), "::", stringify!(temporaries))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteNode>())).user_data as *const _ as usize },
                32usize,
                concat!("Offset of field: ", stringify!(TfLiteNode), "::", stringify!(user_data))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteNode>())).builtin_data as *const _ as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteNode),
                    "::",
                    stringify!(builtin_data)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteNode>())).custom_initial_data as *const _ as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteNode),
                    "::",
                    stringify!(custom_initial_data)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteNode>())).custom_initial_data_size as *const _
                        as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteNode),
                    "::",
                    stringify!(custom_initial_data_size)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteNode>())).delegate as *const _ as usize },
                64usize,
                concat!("Offset of field: ", stringify!(TfLiteNode), "::", stringify!(delegate))
            );
        }

        impl Default for TfLiteNode {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }

        #[repr(C)]
        #[derive(Copy, Clone)]
        pub struct TfLiteEvalTensor {
            pub data: root::TfLitePtrUnion,
            pub dims: *mut root::TfLiteIntArray,
            pub type_: root::TfLiteType,
        }

        #[test]
        fn bindgen_test_layout_TfLiteEvalTensor() {
            assert_eq!(
                ::std::mem::size_of::<TfLiteEvalTensor>(),
                24usize,
                concat!("Size of: ", stringify!(TfLiteEvalTensor))
            );
            assert_eq!(
                ::std::mem::align_of::<TfLiteEvalTensor>(),
                8usize,
                concat!("Alignment of ", stringify!(TfLiteEvalTensor))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteEvalTensor>())).data as *const _ as usize },
                0usize,
                concat!("Offset of field: ", stringify!(TfLiteEvalTensor), "::", stringify!(data))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteEvalTensor>())).dims as *const _ as usize },
                8usize,
                concat!("Offset of field: ", stringify!(TfLiteEvalTensor), "::", stringify!(dims))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteEvalTensor>())).type_ as *const _ as usize },
                16usize,
                concat!("Offset of field: ", stringify!(TfLiteEvalTensor), "::", stringify!(type_))
            );
        }

        impl Default for TfLiteEvalTensor {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }

        impl ::std::fmt::Debug for TfLiteEvalTensor {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(
                    f,
                    "TfLiteEvalTensor {{ data: {:?}, dims: {:?}, type: {:?} }}",
                    self.data, self.dims, self.type_
                )
            }
        }

        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct TfLiteDelegateParams {
            pub delegate: *mut root::TfLiteDelegate,
            pub nodes_to_replace: *mut root::TfLiteIntArray,
            pub input_tensors: *mut root::TfLiteIntArray,
            pub output_tensors: *mut root::TfLiteIntArray,
        }

        #[test]
        fn bindgen_test_layout_TfLiteDelegateParams() {
            assert_eq!(
                ::std::mem::size_of::<TfLiteDelegateParams>(),
                32usize,
                concat!("Size of: ", stringify!(TfLiteDelegateParams))
            );
            assert_eq!(
                ::std::mem::align_of::<TfLiteDelegateParams>(),
                8usize,
                concat!("Alignment of ", stringify!(TfLiteDelegateParams))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteDelegateParams>())).delegate as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteDelegateParams),
                    "::",
                    stringify!(delegate)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteDelegateParams>())).nodes_to_replace as *const _
                        as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteDelegateParams),
                    "::",
                    stringify!(nodes_to_replace)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteDelegateParams>())).input_tensors as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteDelegateParams),
                    "::",
                    stringify!(input_tensors)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteDelegateParams>())).output_tensors as *const _
                        as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteDelegateParams),
                    "::",
                    stringify!(output_tensors)
                )
            );
        }

        impl Default for TfLiteDelegateParams {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }

        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct TfLiteContext {
            pub tensors_size: usize,
            pub GetExecutionPlan: ::std::option::Option<
                unsafe extern "C" fn(
                    context: *mut root::TfLiteContext,
                    execution_plan: *mut *mut root::TfLiteIntArray,
                ) -> root::TfLiteStatus,
            >,
            pub tensors: *mut root::TfLiteTensor,
            pub impl_: *mut ::std::os::raw::c_void,
            pub ResizeTensor: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut root::TfLiteContext,
                    tensor: *mut root::TfLiteTensor,
                    new_size: *mut root::TfLiteIntArray,
                ) -> root::TfLiteStatus,
            >,
            pub ReportError: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut root::TfLiteContext,
                    msg: *const ::std::os::raw::c_char,
                    ...
                ),
            >,
            pub AddTensors: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut root::TfLiteContext,
                    tensors_to_add: ::std::os::raw::c_int,
                    first_new_tensor_index: *mut ::std::os::raw::c_int,
                ) -> root::TfLiteStatus,
            >,
            pub GetNodeAndRegistration: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut root::TfLiteContext,
                    node_index: ::std::os::raw::c_int,
                    node: *mut *mut root::TfLiteNode,
                    registration: *mut *mut root::TfLiteRegistration,
                ) -> root::TfLiteStatus,
            >,
            pub ReplaceNodeSubsetsWithDelegateKernels: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut root::TfLiteContext,
                    registration: root::TfLiteRegistration,
                    nodes_to_replace: *const root::TfLiteIntArray,
                    delegate: *mut root::TfLiteDelegate,
                ) -> root::TfLiteStatus,
            >,
            pub recommended_num_threads: ::std::os::raw::c_int,
            pub GetExternalContext: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut root::TfLiteContext,
                    arg2: root::TfLiteExternalContextType,
                ) -> *mut root::TfLiteExternalContext,
            >,
            pub SetExternalContext: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut root::TfLiteContext,
                    arg2: root::TfLiteExternalContextType,
                    arg3: *mut root::TfLiteExternalContext,
                ),
            >,
            pub allow_fp32_relax_to_fp16: bool,
            pub profiler: *mut ::std::os::raw::c_void,
            pub AllocatePersistentBuffer: ::std::option::Option<
                unsafe extern "C" fn(
                    ctx: *mut root::TfLiteContext,
                    bytes: usize,
                ) -> *mut ::std::os::raw::c_void,
            >,
            pub AllocateBufferForEval: ::std::option::Option<
                unsafe extern "C" fn(
                    ctx: *mut root::TfLiteContext,
                    bytes: usize,
                    ptr: *mut *mut ::std::os::raw::c_void,
                ) -> root::TfLiteStatus,
            >,
            pub RequestScratchBufferInArena: ::std::option::Option<
                unsafe extern "C" fn(
                    ctx: *mut root::TfLiteContext,
                    bytes: usize,
                    buffer_idx: *mut ::std::os::raw::c_int,
                ) -> root::TfLiteStatus,
            >,
            pub GetScratchBuffer: ::std::option::Option<
                unsafe extern "C" fn(
                    ctx: *mut root::TfLiteContext,
                    buffer_idx: ::std::os::raw::c_int,
                ) -> *mut ::std::os::raw::c_void,
            >,
            pub ResizeTensorExplicit: ::std::option::Option<
                unsafe extern "C" fn(
                    ctx: *mut root::TfLiteContext,
                    tensor: *mut root::TfLiteTensor,
                    dims: ::std::os::raw::c_int,
                    shape: *const ::std::os::raw::c_int,
                ) -> root::TfLiteStatus,
            >,
            pub PreviewDelegatePartitioning: ::std::option::Option<
                unsafe extern "C" fn(
                    context: *mut root::TfLiteContext,
                    nodes_to_replace: *const root::TfLiteIntArray,
                    partition_params_array: *mut *mut root::TfLiteDelegateParams,
                    num_partitions: *mut ::std::os::raw::c_int,
                ) -> root::TfLiteStatus,
            >,
            pub GetTensor: ::std::option::Option<
                unsafe extern "C" fn(
                    context: *const root::TfLiteContext,
                    tensor_idx: ::std::os::raw::c_int,
                ) -> *mut root::TfLiteTensor,
            >,
            pub GetEvalTensor: ::std::option::Option<
                unsafe extern "C" fn(
                    context: *const root::TfLiteContext,
                    tensor_idx: ::std::os::raw::c_int,
                ) -> *mut root::TfLiteEvalTensor,
            >,
        }

        #[test]
        fn bindgen_test_layout_TfLiteContext() {
            assert_eq!(
                ::std::mem::size_of::<TfLiteContext>(),
                176usize,
                concat!("Size of: ", stringify!(TfLiteContext))
            );
            assert_eq!(
                ::std::mem::align_of::<TfLiteContext>(),
                8usize,
                concat!("Alignment of ", stringify!(TfLiteContext))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteContext>())).tensors_size as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteContext),
                    "::",
                    stringify!(tensors_size)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteContext>())).GetExecutionPlan as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteContext),
                    "::",
                    stringify!(GetExecutionPlan)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteContext>())).tensors as *const _ as usize },
                16usize,
                concat!("Offset of field: ", stringify!(TfLiteContext), "::", stringify!(tensors))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteContext>())).impl_ as *const _ as usize },
                24usize,
                concat!("Offset of field: ", stringify!(TfLiteContext), "::", stringify!(impl_))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteContext>())).ResizeTensor as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteContext),
                    "::",
                    stringify!(ResizeTensor)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteContext>())).ReportError as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteContext),
                    "::",
                    stringify!(ReportError)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteContext>())).AddTensors as *const _ as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteContext),
                    "::",
                    stringify!(AddTensors)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteContext>())).GetNodeAndRegistration as *const _
                        as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteContext),
                    "::",
                    stringify!(GetNodeAndRegistration)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteContext>())).ReplaceNodeSubsetsWithDelegateKernels
                        as *const _ as usize
                },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteContext),
                    "::",
                    stringify!(ReplaceNodeSubsetsWithDelegateKernels)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteContext>())).recommended_num_threads as *const _
                        as usize
                },
                72usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteContext),
                    "::",
                    stringify!(recommended_num_threads)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteContext>())).GetExternalContext as *const _
                        as usize
                },
                80usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteContext),
                    "::",
                    stringify!(GetExternalContext)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteContext>())).SetExternalContext as *const _
                        as usize
                },
                88usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteContext),
                    "::",
                    stringify!(SetExternalContext)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteContext>())).allow_fp32_relax_to_fp16 as *const _
                        as usize
                },
                96usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteContext),
                    "::",
                    stringify!(allow_fp32_relax_to_fp16)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteContext>())).profiler as *const _ as usize },
                104usize,
                concat!("Offset of field: ", stringify!(TfLiteContext), "::", stringify!(profiler))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteContext>())).AllocatePersistentBuffer as *const _
                        as usize
                },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteContext),
                    "::",
                    stringify!(AllocatePersistentBuffer)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteContext>())).AllocateBufferForEval as *const _
                        as usize
                },
                120usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteContext),
                    "::",
                    stringify!(AllocateBufferForEval)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteContext>())).RequestScratchBufferInArena
                        as *const _ as usize
                },
                128usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteContext),
                    "::",
                    stringify!(RequestScratchBufferInArena)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteContext>())).GetScratchBuffer as *const _ as usize
                },
                136usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteContext),
                    "::",
                    stringify!(GetScratchBuffer)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteContext>())).ResizeTensorExplicit as *const _
                        as usize
                },
                144usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteContext),
                    "::",
                    stringify!(ResizeTensorExplicit)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteContext>())).PreviewDelegatePartitioning
                        as *const _ as usize
                },
                152usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteContext),
                    "::",
                    stringify!(PreviewDelegatePartitioning)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteContext>())).GetTensor as *const _ as usize },
                160usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteContext),
                    "::",
                    stringify!(GetTensor)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteContext>())).GetEvalTensor as *const _ as usize
                },
                168usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteContext),
                    "::",
                    stringify!(GetEvalTensor)
                )
            );
        }

        impl Default for TfLiteContext {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }

        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct TfLiteRegistration {
            pub init: ::std::option::Option<
                unsafe extern "C" fn(
                    context: *mut root::TfLiteContext,
                    buffer: *const ::std::os::raw::c_char,
                    length: usize,
                ) -> *mut ::std::os::raw::c_void,
            >,
            pub free: ::std::option::Option<
                unsafe extern "C" fn(
                    context: *mut root::TfLiteContext,
                    buffer: *mut ::std::os::raw::c_void,
                ),
            >,
            pub prepare: ::std::option::Option<
                unsafe extern "C" fn(
                    context: *mut root::TfLiteContext,
                    node: *mut root::TfLiteNode,
                ) -> root::TfLiteStatus,
            >,
            pub invoke: ::std::option::Option<
                unsafe extern "C" fn(
                    context: *mut root::TfLiteContext,
                    node: *mut root::TfLiteNode,
                ) -> root::TfLiteStatus,
            >,
            pub profiling_string: ::std::option::Option<
                unsafe extern "C" fn(
                    context: *const root::TfLiteContext,
                    node: *const root::TfLiteNode,
                ) -> *const ::std::os::raw::c_char,
            >,
            pub builtin_code: i32,
            pub custom_name: *const ::std::os::raw::c_char,
            pub version: ::std::os::raw::c_int,
        }

        #[test]
        fn bindgen_test_layout_TfLiteRegistration() {
            assert_eq!(
                ::std::mem::size_of::<TfLiteRegistration>(),
                64usize,
                concat!("Size of: ", stringify!(TfLiteRegistration))
            );
            assert_eq!(
                ::std::mem::align_of::<TfLiteRegistration>(),
                8usize,
                concat!("Alignment of ", stringify!(TfLiteRegistration))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteRegistration>())).init as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteRegistration),
                    "::",
                    stringify!(init)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteRegistration>())).free as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteRegistration),
                    "::",
                    stringify!(free)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteRegistration>())).prepare as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteRegistration),
                    "::",
                    stringify!(prepare)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteRegistration>())).invoke as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteRegistration),
                    "::",
                    stringify!(invoke)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteRegistration>())).profiling_string as *const _
                        as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteRegistration),
                    "::",
                    stringify!(profiling_string)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteRegistration>())).builtin_code as *const _ as usize
                },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteRegistration),
                    "::",
                    stringify!(builtin_code)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteRegistration>())).custom_name as *const _ as usize
                },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteRegistration),
                    "::",
                    stringify!(custom_name)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteRegistration>())).version as *const _ as usize
                },
                56usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteRegistration),
                    "::",
                    stringify!(version)
                )
            );
        }

        impl Default for TfLiteRegistration {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }

        #[repr(C)]
        #[derive(Debug, Copy, Clone, PartialEq, Eq)]
        pub struct TfLiteDelegate {
            pub data_: *mut ::std::os::raw::c_void,
            pub Prepare: ::std::option::Option<
                unsafe extern "C" fn(
                    context: *mut root::TfLiteContext,
                    delegate: *mut root::TfLiteDelegate,
                ) -> root::TfLiteStatus,
            >,
            pub CopyFromBufferHandle: ::std::option::Option<
                unsafe extern "C" fn(
                    context: *mut root::TfLiteContext,
                    delegate: *mut root::TfLiteDelegate,
                    buffer_handle: root::TfLiteBufferHandle,
                    tensor: *mut root::TfLiteTensor,
                ) -> root::TfLiteStatus,
            >,
            pub CopyToBufferHandle: ::std::option::Option<
                unsafe extern "C" fn(
                    context: *mut root::TfLiteContext,
                    delegate: *mut root::TfLiteDelegate,
                    buffer_handle: root::TfLiteBufferHandle,
                    tensor: *mut root::TfLiteTensor,
                ) -> root::TfLiteStatus,
            >,
            pub FreeBufferHandle: ::std::option::Option<
                unsafe extern "C" fn(
                    context: *mut root::TfLiteContext,
                    delegate: *mut root::TfLiteDelegate,
                    handle: *mut root::TfLiteBufferHandle,
                ),
            >,
            pub flags: i64,
        }

        #[test]
        fn bindgen_test_layout_TfLiteDelegate() {
            assert_eq!(
                ::std::mem::size_of::<TfLiteDelegate>(),
                48usize,
                concat!("Size of: ", stringify!(TfLiteDelegate))
            );
            assert_eq!(
                ::std::mem::align_of::<TfLiteDelegate>(),
                8usize,
                concat!("Alignment of ", stringify!(TfLiteDelegate))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteDelegate>())).data_ as *const _ as usize },
                0usize,
                concat!("Offset of field: ", stringify!(TfLiteDelegate), "::", stringify!(data_))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteDelegate>())).Prepare as *const _ as usize },
                8usize,
                concat!("Offset of field: ", stringify!(TfLiteDelegate), "::", stringify!(Prepare))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteDelegate>())).CopyFromBufferHandle as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteDelegate),
                    "::",
                    stringify!(CopyFromBufferHandle)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteDelegate>())).CopyToBufferHandle as *const _
                        as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteDelegate),
                    "::",
                    stringify!(CopyToBufferHandle)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<TfLiteDelegate>())).FreeBufferHandle as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TfLiteDelegate),
                    "::",
                    stringify!(FreeBufferHandle)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TfLiteDelegate>())).flags as *const _ as usize },
                40usize,
                concat!("Offset of field: ", stringify!(TfLiteDelegate), "::", stringify!(flags))
            );
        }

        impl Default for TfLiteDelegate {
            fn default() -> Self {
                unsafe { ::std::mem::zeroed() }
            }
        }

        pub mod tflite {
            #[allow(unused_imports)]
            use self::super::super::root;

            pub mod delegate {
                #[allow(unused_imports)]
                use self::super::super::super::root;
            }

            #[doc = " interpreter.Invoke();"]
            #[doc = " </code></pre>"]
            #[doc = ""]
            #[doc = " Note: for nearly all practical use cases, one should not directly construct"]
            #[doc = " an Interpreter object, but rather use the InterpreterBuilder."]
            #[repr(C)]
            #[repr(align(8))]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct Interpreter {
                pub _bindgen_opaque_blob: [u64; 26usize],
            }

            #[test]
            fn bindgen_test_layout_Interpreter() {
                assert_eq!(
                    ::std::mem::size_of::<Interpreter>(),
                    208usize,
                    concat!("Size of: ", stringify!(Interpreter))
                );
                assert_eq!(
                    ::std::mem::align_of::<Interpreter>(),
                    8usize,
                    concat!("Alignment of ", stringify!(Interpreter))
                );
            }

            impl root::tflite::TensorType {
                pub const TensorType_MIN: root::tflite::TensorType = TensorType::TensorType_FLOAT32;
            }

            impl root::tflite::TensorType {
                pub const TensorType_MAX: root::tflite::TensorType =
                    TensorType::TensorType_COMPLEX128;
            }

            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum TensorType {
                TensorType_FLOAT32 = 0,
                TensorType_FLOAT16 = 1,
                TensorType_INT32 = 2,
                TensorType_UINT8 = 3,
                TensorType_INT64 = 4,
                TensorType_STRING = 5,
                TensorType_BOOL = 6,
                TensorType_INT16 = 7,
                TensorType_COMPLEX64 = 8,
                TensorType_INT8 = 9,
                TensorType_FLOAT64 = 10,
                TensorType_COMPLEX128 = 11,
            }

            impl root::tflite::QuantizationDetails {
                pub const QuantizationDetails_MIN: root::tflite::QuantizationDetails =
                    QuantizationDetails::QuantizationDetails_NONE;
            }

            impl root::tflite::QuantizationDetails {
                pub const QuantizationDetails_MAX: root::tflite::QuantizationDetails =
                    QuantizationDetails::QuantizationDetails_CustomQuantization;
            }

            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum QuantizationDetails {
                QuantizationDetails_NONE = 0,
                QuantizationDetails_CustomQuantization = 1,
            }

            #[repr(C)]
            #[derive(Debug, PartialEq, Eq)]
            pub struct QuantizationDetailsUnion {
                pub type_: root::tflite::QuantizationDetails,
                pub value: *mut ::std::os::raw::c_void,
            }

            #[test]
            fn bindgen_test_layout_QuantizationDetailsUnion() {
                assert_eq!(
                    ::std::mem::size_of::<QuantizationDetailsUnion>(),
                    16usize,
                    concat!("Size of: ", stringify!(QuantizationDetailsUnion))
                );
                assert_eq!(
                    ::std::mem::align_of::<QuantizationDetailsUnion>(),
                    8usize,
                    concat!("Alignment of ", stringify!(QuantizationDetailsUnion))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<QuantizationDetailsUnion>())).type_ as *const _
                            as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(QuantizationDetailsUnion),
                        "::",
                        stringify!(type_)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<QuantizationDetailsUnion>())).value as *const _
                            as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(QuantizationDetailsUnion),
                        "::",
                        stringify!(value)
                    )
                );
            }

            impl Default for QuantizationDetailsUnion {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            impl root::tflite::DimensionType {
                pub const DimensionType_MIN: root::tflite::DimensionType =
                    DimensionType::DimensionType_DENSE;
            }

            impl root::tflite::DimensionType {
                pub const DimensionType_MAX: root::tflite::DimensionType =
                    DimensionType::DimensionType_SPARSE_CSR;
            }

            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum DimensionType {
                DimensionType_DENSE = 0,
                DimensionType_SPARSE_CSR = 1,
            }

            impl root::tflite::SparseIndexVector {
                pub const SparseIndexVector_MIN: root::tflite::SparseIndexVector =
                    SparseIndexVector::SparseIndexVector_NONE;
            }

            impl root::tflite::SparseIndexVector {
                pub const SparseIndexVector_MAX: root::tflite::SparseIndexVector =
                    SparseIndexVector::SparseIndexVector_Uint8Vector;
            }

            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum SparseIndexVector {
                SparseIndexVector_NONE = 0,
                SparseIndexVector_Int32Vector = 1,
                SparseIndexVector_Uint16Vector = 2,
                SparseIndexVector_Uint8Vector = 3,
            }

            #[repr(C)]
            #[derive(Debug, PartialEq, Eq)]
            pub struct SparseIndexVectorUnion {
                pub type_: root::tflite::SparseIndexVector,
                pub value: *mut ::std::os::raw::c_void,
            }

            #[test]
            fn bindgen_test_layout_SparseIndexVectorUnion() {
                assert_eq!(
                    ::std::mem::size_of::<SparseIndexVectorUnion>(),
                    16usize,
                    concat!("Size of: ", stringify!(SparseIndexVectorUnion))
                );
                assert_eq!(
                    ::std::mem::align_of::<SparseIndexVectorUnion>(),
                    8usize,
                    concat!("Alignment of ", stringify!(SparseIndexVectorUnion))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SparseIndexVectorUnion>())).type_ as *const _
                            as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SparseIndexVectorUnion),
                        "::",
                        stringify!(type_)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SparseIndexVectorUnion>())).value as *const _
                            as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SparseIndexVectorUnion),
                        "::",
                        stringify!(value)
                    )
                );
            }

            impl Default for SparseIndexVectorUnion {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            impl root::tflite::BuiltinOperator {
                pub const BuiltinOperator_MIN: root::tflite::BuiltinOperator =
                    BuiltinOperator::BuiltinOperator_ADD;
            }

            impl root::tflite::BuiltinOperator {
                pub const BuiltinOperator_MAX: root::tflite::BuiltinOperator =
                    BuiltinOperator::BuiltinOperator_CUMSUM;
            }

            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum BuiltinOperator {
                BuiltinOperator_ADD = 0,
                BuiltinOperator_AVERAGE_POOL_2D = 1,
                BuiltinOperator_CONCATENATION = 2,
                BuiltinOperator_CONV_2D = 3,
                BuiltinOperator_DEPTHWISE_CONV_2D = 4,
                BuiltinOperator_DEPTH_TO_SPACE = 5,
                BuiltinOperator_DEQUANTIZE = 6,
                BuiltinOperator_EMBEDDING_LOOKUP = 7,
                BuiltinOperator_FLOOR = 8,
                BuiltinOperator_FULLY_CONNECTED = 9,
                BuiltinOperator_HASHTABLE_LOOKUP = 10,
                BuiltinOperator_L2_NORMALIZATION = 11,
                BuiltinOperator_L2_POOL_2D = 12,
                BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION = 13,
                BuiltinOperator_LOGISTIC = 14,
                BuiltinOperator_LSH_PROJECTION = 15,
                BuiltinOperator_LSTM = 16,
                BuiltinOperator_MAX_POOL_2D = 17,
                BuiltinOperator_MUL = 18,
                BuiltinOperator_RELU = 19,
                BuiltinOperator_RELU_N1_TO_1 = 20,
                BuiltinOperator_RELU6 = 21,
                BuiltinOperator_RESHAPE = 22,
                BuiltinOperator_RESIZE_BILINEAR = 23,
                BuiltinOperator_RNN = 24,
                BuiltinOperator_SOFTMAX = 25,
                BuiltinOperator_SPACE_TO_DEPTH = 26,
                BuiltinOperator_SVDF = 27,
                BuiltinOperator_TANH = 28,
                BuiltinOperator_CONCAT_EMBEDDINGS = 29,
                BuiltinOperator_SKIP_GRAM = 30,
                BuiltinOperator_CALL = 31,
                BuiltinOperator_CUSTOM = 32,
                BuiltinOperator_EMBEDDING_LOOKUP_SPARSE = 33,
                BuiltinOperator_PAD = 34,
                BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN = 35,
                BuiltinOperator_GATHER = 36,
                BuiltinOperator_BATCH_TO_SPACE_ND = 37,
                BuiltinOperator_SPACE_TO_BATCH_ND = 38,
                BuiltinOperator_TRANSPOSE = 39,
                BuiltinOperator_MEAN = 40,
                BuiltinOperator_SUB = 41,
                BuiltinOperator_DIV = 42,
                BuiltinOperator_SQUEEZE = 43,
                BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM = 44,
                BuiltinOperator_STRIDED_SLICE = 45,
                BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN = 46,
                BuiltinOperator_EXP = 47,
                BuiltinOperator_TOPK_V2 = 48,
                BuiltinOperator_SPLIT = 49,
                BuiltinOperator_LOG_SOFTMAX = 50,
                BuiltinOperator_DELEGATE = 51,
                BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM = 52,
                BuiltinOperator_CAST = 53,
                BuiltinOperator_PRELU = 54,
                BuiltinOperator_MAXIMUM = 55,
                BuiltinOperator_ARG_MAX = 56,
                BuiltinOperator_MINIMUM = 57,
                BuiltinOperator_LESS = 58,
                BuiltinOperator_NEG = 59,
                BuiltinOperator_PADV2 = 60,
                BuiltinOperator_GREATER = 61,
                BuiltinOperator_GREATER_EQUAL = 62,
                BuiltinOperator_LESS_EQUAL = 63,
                BuiltinOperator_SELECT = 64,
                BuiltinOperator_SLICE = 65,
                BuiltinOperator_SIN = 66,
                BuiltinOperator_TRANSPOSE_CONV = 67,
                BuiltinOperator_SPARSE_TO_DENSE = 68,
                BuiltinOperator_TILE = 69,
                BuiltinOperator_EXPAND_DIMS = 70,
                BuiltinOperator_EQUAL = 71,
                BuiltinOperator_NOT_EQUAL = 72,
                BuiltinOperator_LOG = 73,
                BuiltinOperator_SUM = 74,
                BuiltinOperator_SQRT = 75,
                BuiltinOperator_RSQRT = 76,
                BuiltinOperator_SHAPE = 77,
                BuiltinOperator_POW = 78,
                BuiltinOperator_ARG_MIN = 79,
                BuiltinOperator_FAKE_QUANT = 80,
                BuiltinOperator_REDUCE_PROD = 81,
                BuiltinOperator_REDUCE_MAX = 82,
                BuiltinOperator_PACK = 83,
                BuiltinOperator_LOGICAL_OR = 84,
                BuiltinOperator_ONE_HOT = 85,
                BuiltinOperator_LOGICAL_AND = 86,
                BuiltinOperator_LOGICAL_NOT = 87,
                BuiltinOperator_UNPACK = 88,
                BuiltinOperator_REDUCE_MIN = 89,
                BuiltinOperator_FLOOR_DIV = 90,
                BuiltinOperator_REDUCE_ANY = 91,
                BuiltinOperator_SQUARE = 92,
                BuiltinOperator_ZEROS_LIKE = 93,
                BuiltinOperator_FILL = 94,
                BuiltinOperator_FLOOR_MOD = 95,
                BuiltinOperator_RANGE = 96,
                BuiltinOperator_RESIZE_NEAREST_NEIGHBOR = 97,
                BuiltinOperator_LEAKY_RELU = 98,
                BuiltinOperator_SQUARED_DIFFERENCE = 99,
                BuiltinOperator_MIRROR_PAD = 100,
                BuiltinOperator_ABS = 101,
                BuiltinOperator_SPLIT_V = 102,
                BuiltinOperator_UNIQUE = 103,
                BuiltinOperator_CEIL = 104,
                BuiltinOperator_REVERSE_V2 = 105,
                BuiltinOperator_ADD_N = 106,
                BuiltinOperator_GATHER_ND = 107,
                BuiltinOperator_COS = 108,
                BuiltinOperator_WHERE = 109,
                BuiltinOperator_RANK = 110,
                BuiltinOperator_ELU = 111,
                BuiltinOperator_REVERSE_SEQUENCE = 112,
                BuiltinOperator_MATRIX_DIAG = 113,
                BuiltinOperator_QUANTIZE = 114,
                BuiltinOperator_MATRIX_SET_DIAG = 115,
                BuiltinOperator_ROUND = 116,
                BuiltinOperator_HARD_SWISH = 117,
                BuiltinOperator_IF = 118,
                BuiltinOperator_WHILE = 119,
                BuiltinOperator_NON_MAX_SUPPRESSION_V4 = 120,
                BuiltinOperator_NON_MAX_SUPPRESSION_V5 = 121,
                BuiltinOperator_SCATTER_ND = 122,
                BuiltinOperator_SELECT_V2 = 123,
                BuiltinOperator_DENSIFY = 124,
                BuiltinOperator_SEGMENT_SUM = 125,
                BuiltinOperator_BATCH_MATMUL = 126,
                BuiltinOperator_PLACEHOLDER_FOR_GREATER_OP_CODES = 127,
                BuiltinOperator_CUMSUM = 128,
            }

            impl root::tflite::BuiltinOptions {
                pub const BuiltinOptions_MIN: root::tflite::BuiltinOptions =
                    BuiltinOptions::BuiltinOptions_NONE;
            }

            impl root::tflite::BuiltinOptions {
                pub const BuiltinOptions_MAX: root::tflite::BuiltinOptions =
                    BuiltinOptions::BuiltinOptions_CumsumOptions;
            }

            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum BuiltinOptions {
                BuiltinOptions_NONE = 0,
                BuiltinOptions_Conv2DOptions = 1,
                BuiltinOptions_DepthwiseConv2DOptions = 2,
                BuiltinOptions_ConcatEmbeddingsOptions = 3,
                BuiltinOptions_LSHProjectionOptions = 4,
                BuiltinOptions_Pool2DOptions = 5,
                BuiltinOptions_SVDFOptions = 6,
                BuiltinOptions_RNNOptions = 7,
                BuiltinOptions_FullyConnectedOptions = 8,
                BuiltinOptions_SoftmaxOptions = 9,
                BuiltinOptions_ConcatenationOptions = 10,
                BuiltinOptions_AddOptions = 11,
                BuiltinOptions_L2NormOptions = 12,
                BuiltinOptions_LocalResponseNormalizationOptions = 13,
                BuiltinOptions_LSTMOptions = 14,
                BuiltinOptions_ResizeBilinearOptions = 15,
                BuiltinOptions_CallOptions = 16,
                BuiltinOptions_ReshapeOptions = 17,
                BuiltinOptions_SkipGramOptions = 18,
                BuiltinOptions_SpaceToDepthOptions = 19,
                BuiltinOptions_EmbeddingLookupSparseOptions = 20,
                BuiltinOptions_MulOptions = 21,
                BuiltinOptions_PadOptions = 22,
                BuiltinOptions_GatherOptions = 23,
                BuiltinOptions_BatchToSpaceNDOptions = 24,
                BuiltinOptions_SpaceToBatchNDOptions = 25,
                BuiltinOptions_TransposeOptions = 26,
                BuiltinOptions_ReducerOptions = 27,
                BuiltinOptions_SubOptions = 28,
                BuiltinOptions_DivOptions = 29,
                BuiltinOptions_SqueezeOptions = 30,
                BuiltinOptions_SequenceRNNOptions = 31,
                BuiltinOptions_StridedSliceOptions = 32,
                BuiltinOptions_ExpOptions = 33,
                BuiltinOptions_TopKV2Options = 34,
                BuiltinOptions_SplitOptions = 35,
                BuiltinOptions_LogSoftmaxOptions = 36,
                BuiltinOptions_CastOptions = 37,
                BuiltinOptions_DequantizeOptions = 38,
                BuiltinOptions_MaximumMinimumOptions = 39,
                BuiltinOptions_ArgMaxOptions = 40,
                BuiltinOptions_LessOptions = 41,
                BuiltinOptions_NegOptions = 42,
                BuiltinOptions_PadV2Options = 43,
                BuiltinOptions_GreaterOptions = 44,
                BuiltinOptions_GreaterEqualOptions = 45,
                BuiltinOptions_LessEqualOptions = 46,
                BuiltinOptions_SelectOptions = 47,
                BuiltinOptions_SliceOptions = 48,
                BuiltinOptions_TransposeConvOptions = 49,
                BuiltinOptions_SparseToDenseOptions = 50,
                BuiltinOptions_TileOptions = 51,
                BuiltinOptions_ExpandDimsOptions = 52,
                BuiltinOptions_EqualOptions = 53,
                BuiltinOptions_NotEqualOptions = 54,
                BuiltinOptions_ShapeOptions = 55,
                BuiltinOptions_PowOptions = 56,
                BuiltinOptions_ArgMinOptions = 57,
                BuiltinOptions_FakeQuantOptions = 58,
                BuiltinOptions_PackOptions = 59,
                BuiltinOptions_LogicalOrOptions = 60,
                BuiltinOptions_OneHotOptions = 61,
                BuiltinOptions_LogicalAndOptions = 62,
                BuiltinOptions_LogicalNotOptions = 63,
                BuiltinOptions_UnpackOptions = 64,
                BuiltinOptions_FloorDivOptions = 65,
                BuiltinOptions_SquareOptions = 66,
                BuiltinOptions_ZerosLikeOptions = 67,
                BuiltinOptions_FillOptions = 68,
                BuiltinOptions_BidirectionalSequenceLSTMOptions = 69,
                BuiltinOptions_BidirectionalSequenceRNNOptions = 70,
                BuiltinOptions_UnidirectionalSequenceLSTMOptions = 71,
                BuiltinOptions_FloorModOptions = 72,
                BuiltinOptions_RangeOptions = 73,
                BuiltinOptions_ResizeNearestNeighborOptions = 74,
                BuiltinOptions_LeakyReluOptions = 75,
                BuiltinOptions_SquaredDifferenceOptions = 76,
                BuiltinOptions_MirrorPadOptions = 77,
                BuiltinOptions_AbsOptions = 78,
                BuiltinOptions_SplitVOptions = 79,
                BuiltinOptions_UniqueOptions = 80,
                BuiltinOptions_ReverseV2Options = 81,
                BuiltinOptions_AddNOptions = 82,
                BuiltinOptions_GatherNdOptions = 83,
                BuiltinOptions_CosOptions = 84,
                BuiltinOptions_WhereOptions = 85,
                BuiltinOptions_RankOptions = 86,
                BuiltinOptions_ReverseSequenceOptions = 87,
                BuiltinOptions_MatrixDiagOptions = 88,
                BuiltinOptions_QuantizeOptions = 89,
                BuiltinOptions_MatrixSetDiagOptions = 90,
                BuiltinOptions_HardSwishOptions = 91,
                BuiltinOptions_IfOptions = 92,
                BuiltinOptions_WhileOptions = 93,
                BuiltinOptions_DepthToSpaceOptions = 94,
                BuiltinOptions_NonMaxSuppressionV4Options = 95,
                BuiltinOptions_NonMaxSuppressionV5Options = 96,
                BuiltinOptions_ScatterNdOptions = 97,
                BuiltinOptions_SelectV2Options = 98,
                BuiltinOptions_DensifyOptions = 99,
                BuiltinOptions_SegmentSumOptions = 100,
                BuiltinOptions_BatchMatMulOptions = 101,
                BuiltinOptions_CumsumOptions = 102,
            }

            #[repr(C)]
            #[derive(Debug, PartialEq, Eq)]
            pub struct BuiltinOptionsUnion {
                pub type_: root::tflite::BuiltinOptions,
                pub value: *mut ::std::os::raw::c_void,
            }

            #[test]
            fn bindgen_test_layout_BuiltinOptionsUnion() {
                assert_eq!(
                    ::std::mem::size_of::<BuiltinOptionsUnion>(),
                    16usize,
                    concat!("Size of: ", stringify!(BuiltinOptionsUnion))
                );
                assert_eq!(
                    ::std::mem::align_of::<BuiltinOptionsUnion>(),
                    8usize,
                    concat!("Alignment of ", stringify!(BuiltinOptionsUnion))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<BuiltinOptionsUnion>())).type_ as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BuiltinOptionsUnion),
                        "::",
                        stringify!(type_)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<BuiltinOptionsUnion>())).value as *const _ as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BuiltinOptionsUnion),
                        "::",
                        stringify!(value)
                    )
                );
            }

            impl Default for BuiltinOptionsUnion {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            impl root::tflite::Padding {
                pub const Padding_MIN: root::tflite::Padding = Padding::Padding_SAME;
            }

            impl root::tflite::Padding {
                pub const Padding_MAX: root::tflite::Padding = Padding::Padding_VALID;
            }

            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum Padding {
                Padding_SAME = 0,
                Padding_VALID = 1,
            }

            impl root::tflite::ActivationFunctionType {
                pub const ActivationFunctionType_MIN: root::tflite::ActivationFunctionType =
                    ActivationFunctionType::ActivationFunctionType_NONE;
            }

            impl root::tflite::ActivationFunctionType {
                pub const ActivationFunctionType_MAX: root::tflite::ActivationFunctionType =
                    ActivationFunctionType::ActivationFunctionType_SIGN_BIT;
            }

            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum ActivationFunctionType {
                ActivationFunctionType_NONE = 0,
                ActivationFunctionType_RELU = 1,
                ActivationFunctionType_RELU_N1_TO_1 = 2,
                ActivationFunctionType_RELU6 = 3,
                ActivationFunctionType_TANH = 4,
                ActivationFunctionType_SIGN_BIT = 5,
            }

            impl root::tflite::LSHProjectionType {
                pub const LSHProjectionType_MIN: root::tflite::LSHProjectionType =
                    LSHProjectionType::LSHProjectionType_UNKNOWN;
            }

            impl root::tflite::LSHProjectionType {
                pub const LSHProjectionType_MAX: root::tflite::LSHProjectionType =
                    LSHProjectionType::LSHProjectionType_DENSE;
            }

            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum LSHProjectionType {
                LSHProjectionType_UNKNOWN = 0,
                LSHProjectionType_SPARSE = 1,
                LSHProjectionType_DENSE = 2,
            }

            impl root::tflite::FullyConnectedOptionsWeightsFormat {
                pub const FullyConnectedOptionsWeightsFormat_MIN:
                    root::tflite::FullyConnectedOptionsWeightsFormat =
                    FullyConnectedOptionsWeightsFormat::FullyConnectedOptionsWeightsFormat_DEFAULT;
            }

            impl root::tflite::FullyConnectedOptionsWeightsFormat {
                pub const FullyConnectedOptionsWeightsFormat_MAX: root::tflite::FullyConnectedOptionsWeightsFormat = FullyConnectedOptionsWeightsFormat::FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8;
            }

            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum FullyConnectedOptionsWeightsFormat {
                FullyConnectedOptionsWeightsFormat_DEFAULT = 0,
                FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8 = 1,
            }

            impl root::tflite::LSTMKernelType {
                pub const LSTMKernelType_MIN: root::tflite::LSTMKernelType =
                    LSTMKernelType::LSTMKernelType_FULL;
            }

            impl root::tflite::LSTMKernelType {
                pub const LSTMKernelType_MAX: root::tflite::LSTMKernelType =
                    LSTMKernelType::LSTMKernelType_BASIC;
            }

            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum LSTMKernelType {
                LSTMKernelType_FULL = 0,
                LSTMKernelType_BASIC = 1,
            }

            impl root::tflite::CombinerType {
                pub const CombinerType_MIN: root::tflite::CombinerType =
                    CombinerType::CombinerType_SUM;
            }

            impl root::tflite::CombinerType {
                pub const CombinerType_MAX: root::tflite::CombinerType =
                    CombinerType::CombinerType_SQRTN;
            }

            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum CombinerType {
                CombinerType_SUM = 0,
                CombinerType_MEAN = 1,
                CombinerType_SQRTN = 2,
            }

            impl root::tflite::MirrorPadMode {
                pub const MirrorPadMode_MIN: root::tflite::MirrorPadMode =
                    MirrorPadMode::MirrorPadMode_REFLECT;
            }

            impl root::tflite::MirrorPadMode {
                pub const MirrorPadMode_MAX: root::tflite::MirrorPadMode =
                    MirrorPadMode::MirrorPadMode_SYMMETRIC;
            }

            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum MirrorPadMode {
                MirrorPadMode_REFLECT = 0,
                MirrorPadMode_SYMMETRIC = 1,
            }

            impl root::tflite::CustomOptionsFormat {
                pub const CustomOptionsFormat_MIN: root::tflite::CustomOptionsFormat =
                    CustomOptionsFormat::CustomOptionsFormat_FLEXBUFFERS;
            }

            impl root::tflite::CustomOptionsFormat {
                pub const CustomOptionsFormat_MAX: root::tflite::CustomOptionsFormat =
                    CustomOptionsFormat::CustomOptionsFormat_FLEXBUFFERS;
            }

            #[repr(u32)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum CustomOptionsFormat {
                CustomOptionsFormat_FLEXBUFFERS = 0,
            }

            #[repr(C)]
            #[derive(Debug, PartialEq)]
            pub struct QuantizationParametersT {
                pub _base: root::flatbuffers::NativeTable,
                pub min: root::std::vector,
                pub max: root::std::vector,
                pub scale: root::std::vector,
                pub zero_point: root::std::vector,
                pub details: root::tflite::QuantizationDetailsUnion,
                pub quantized_dimension: i32,
            }

            #[test]
            fn bindgen_test_layout_QuantizationParametersT() {
                assert_eq!(
                    ::std::mem::size_of::<QuantizationParametersT>(),
                    120usize,
                    concat!("Size of: ", stringify!(QuantizationParametersT))
                );
                assert_eq!(
                    ::std::mem::align_of::<QuantizationParametersT>(),
                    8usize,
                    concat!("Alignment of ", stringify!(QuantizationParametersT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<QuantizationParametersT>())).min as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(QuantizationParametersT),
                        "::",
                        stringify!(min)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<QuantizationParametersT>())).max as *const _ as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(QuantizationParametersT),
                        "::",
                        stringify!(max)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<QuantizationParametersT>())).scale as *const _
                            as usize
                    },
                    48usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(QuantizationParametersT),
                        "::",
                        stringify!(scale)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<QuantizationParametersT>())).zero_point as *const _
                            as usize
                    },
                    72usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(QuantizationParametersT),
                        "::",
                        stringify!(zero_point)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<QuantizationParametersT>())).details as *const _
                            as usize
                    },
                    96usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(QuantizationParametersT),
                        "::",
                        stringify!(details)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<QuantizationParametersT>())).quantized_dimension
                            as *const _ as usize
                    },
                    112usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(QuantizationParametersT),
                        "::",
                        stringify!(quantized_dimension)
                    )
                );
            }

            impl Default for QuantizationParametersT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct QuantizationParameters {
                pub _base: root::flatbuffers::Table,
            }

            pub type QuantizationParameters_NativeTableType = root::tflite::QuantizationParametersT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum QuantizationParameters_FlatBuffersVTableOffset {
                VT_MIN = 4,
                VT_MAX = 6,
                VT_SCALE = 8,
                VT_ZERO_POINT = 10,
                VT_DETAILS_TYPE = 12,
                VT_DETAILS = 14,
                VT_QUANTIZED_DIMENSION = 16,
            }

            #[test]
            fn bindgen_test_layout_QuantizationParameters() {
                assert_eq!(
                    ::std::mem::size_of::<QuantizationParameters>(),
                    1usize,
                    concat!("Size of: ", stringify!(QuantizationParameters))
                );
                assert_eq!(
                    ::std::mem::align_of::<QuantizationParameters>(),
                    1usize,
                    concat!("Alignment of ", stringify!(QuantizationParameters))
                );
            }

            #[repr(C)]
            #[derive(Debug, PartialEq, Eq)]
            pub struct DimensionMetadataT {
                pub _base: root::flatbuffers::NativeTable,
                pub format: root::tflite::DimensionType,
                pub dense_size: i32,
                pub array_segments: root::tflite::SparseIndexVectorUnion,
                pub array_indices: root::tflite::SparseIndexVectorUnion,
            }

            #[test]
            fn bindgen_test_layout_DimensionMetadataT() {
                assert_eq!(
                    ::std::mem::size_of::<DimensionMetadataT>(),
                    40usize,
                    concat!("Size of: ", stringify!(DimensionMetadataT))
                );
                assert_eq!(
                    ::std::mem::align_of::<DimensionMetadataT>(),
                    8usize,
                    concat!("Alignment of ", stringify!(DimensionMetadataT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<DimensionMetadataT>())).format as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DimensionMetadataT),
                        "::",
                        stringify!(format)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<DimensionMetadataT>())).dense_size as *const _
                            as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DimensionMetadataT),
                        "::",
                        stringify!(dense_size)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<DimensionMetadataT>())).array_segments as *const _
                            as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DimensionMetadataT),
                        "::",
                        stringify!(array_segments)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<DimensionMetadataT>())).array_indices as *const _
                            as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DimensionMetadataT),
                        "::",
                        stringify!(array_indices)
                    )
                );
            }

            impl Default for DimensionMetadataT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct DimensionMetadata {
                pub _base: root::flatbuffers::Table,
            }

            pub type DimensionMetadata_NativeTableType = root::tflite::DimensionMetadataT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum DimensionMetadata_FlatBuffersVTableOffset {
                VT_FORMAT = 4,
                VT_DENSE_SIZE = 6,
                VT_ARRAY_SEGMENTS_TYPE = 8,
                VT_ARRAY_SEGMENTS = 10,
                VT_ARRAY_INDICES_TYPE = 12,
                VT_ARRAY_INDICES = 14,
            }

            #[test]
            fn bindgen_test_layout_DimensionMetadata() {
                assert_eq!(
                    ::std::mem::size_of::<DimensionMetadata>(),
                    1usize,
                    concat!("Size of: ", stringify!(DimensionMetadata))
                );
                assert_eq!(
                    ::std::mem::align_of::<DimensionMetadata>(),
                    1usize,
                    concat!("Alignment of ", stringify!(DimensionMetadata))
                );
            }

            #[repr(C)]
            #[derive(Debug, PartialEq, Eq)]
            pub struct SparsityParametersT {
                pub _base: root::flatbuffers::NativeTable,
                pub traversal_order: root::std::vector,
                pub block_map: root::std::vector,
                pub dim_metadata: root::std::vector,
            }

            #[test]
            fn bindgen_test_layout_SparsityParametersT() {
                assert_eq!(
                    ::std::mem::size_of::<SparsityParametersT>(),
                    72usize,
                    concat!("Size of: ", stringify!(SparsityParametersT))
                );
                assert_eq!(
                    ::std::mem::align_of::<SparsityParametersT>(),
                    8usize,
                    concat!("Alignment of ", stringify!(SparsityParametersT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SparsityParametersT>())).traversal_order as *const _
                            as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SparsityParametersT),
                        "::",
                        stringify!(traversal_order)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SparsityParametersT>())).block_map as *const _
                            as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SparsityParametersT),
                        "::",
                        stringify!(block_map)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SparsityParametersT>())).dim_metadata as *const _
                            as usize
                    },
                    48usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SparsityParametersT),
                        "::",
                        stringify!(dim_metadata)
                    )
                );
            }

            impl Default for SparsityParametersT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SparsityParameters {
                pub _base: root::flatbuffers::Table,
            }

            pub type SparsityParameters_NativeTableType = root::tflite::SparsityParametersT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum SparsityParameters_FlatBuffersVTableOffset {
                VT_TRAVERSAL_ORDER = 4,
                VT_BLOCK_MAP = 6,
                VT_DIM_METADATA = 8,
            }

            #[test]
            fn bindgen_test_layout_SparsityParameters() {
                assert_eq!(
                    ::std::mem::size_of::<SparsityParameters>(),
                    1usize,
                    concat!("Size of: ", stringify!(SparsityParameters))
                );
                assert_eq!(
                    ::std::mem::align_of::<SparsityParameters>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SparsityParameters))
                );
            }

            #[repr(C)]
            #[derive(Debug, PartialEq)]
            pub struct TensorT {
                pub _base: root::flatbuffers::NativeTable,
                pub shape: root::std::vector,
                pub type_: root::tflite::TensorType,
                pub buffer: u32,
                pub name: root::std::string,
                pub quantization: root::std::unique_ptr,
                pub is_variable: bool,
                pub sparsity: root::std::unique_ptr,
                pub shape_signature: root::std::vector,
            }

            #[test]
            fn bindgen_test_layout_TensorT() {
                assert_eq!(
                    ::std::mem::size_of::<TensorT>(),
                    112usize,
                    concat!("Size of: ", stringify!(TensorT))
                );
                assert_eq!(
                    ::std::mem::align_of::<TensorT>(),
                    8usize,
                    concat!("Alignment of ", stringify!(TensorT))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<TensorT>())).shape as *const _ as usize },
                    0usize,
                    concat!("Offset of field: ", stringify!(TensorT), "::", stringify!(shape))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<TensorT>())).type_ as *const _ as usize },
                    24usize,
                    concat!("Offset of field: ", stringify!(TensorT), "::", stringify!(type_))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<TensorT>())).buffer as *const _ as usize },
                    28usize,
                    concat!("Offset of field: ", stringify!(TensorT), "::", stringify!(buffer))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<TensorT>())).name as *const _ as usize },
                    32usize,
                    concat!("Offset of field: ", stringify!(TensorT), "::", stringify!(name))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<TensorT>())).quantization as *const _ as usize
                    },
                    64usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(TensorT),
                        "::",
                        stringify!(quantization)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<TensorT>())).is_variable as *const _ as usize },
                    72usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(TensorT),
                        "::",
                        stringify!(is_variable)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<TensorT>())).sparsity as *const _ as usize },
                    80usize,
                    concat!("Offset of field: ", stringify!(TensorT), "::", stringify!(sparsity))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<TensorT>())).shape_signature as *const _ as usize
                    },
                    88usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(TensorT),
                        "::",
                        stringify!(shape_signature)
                    )
                );
            }

            impl Default for TensorT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct Tensor {
                pub _base: root::flatbuffers::Table,
            }

            pub type Tensor_NativeTableType = root::tflite::TensorT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum Tensor_FlatBuffersVTableOffset {
                VT_SHAPE = 4,
                VT_TYPE = 6,
                VT_BUFFER = 8,
                VT_NAME = 10,
                VT_QUANTIZATION = 12,
                VT_IS_VARIABLE = 14,
                VT_SPARSITY = 16,
                VT_SHAPE_SIGNATURE = 18,
            }

            #[test]
            fn bindgen_test_layout_Tensor() {
                assert_eq!(
                    ::std::mem::size_of::<Tensor>(),
                    1usize,
                    concat!("Size of: ", stringify!(Tensor))
                );
                assert_eq!(
                    ::std::mem::align_of::<Tensor>(),
                    1usize,
                    concat!("Alignment of ", stringify!(Tensor))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct Conv2DOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub padding: root::tflite::Padding,
                pub stride_w: i32,
                pub stride_h: i32,
                pub fused_activation_function: root::tflite::ActivationFunctionType,
                pub dilation_w_factor: i32,
                pub dilation_h_factor: i32,
            }

            #[test]
            fn bindgen_test_layout_Conv2DOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<Conv2DOptionsT>(),
                    24usize,
                    concat!("Size of: ", stringify!(Conv2DOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<Conv2DOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(Conv2DOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<Conv2DOptionsT>())).padding as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Conv2DOptionsT),
                        "::",
                        stringify!(padding)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<Conv2DOptionsT>())).stride_w as *const _ as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Conv2DOptionsT),
                        "::",
                        stringify!(stride_w)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<Conv2DOptionsT>())).stride_h as *const _ as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Conv2DOptionsT),
                        "::",
                        stringify!(stride_h)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<Conv2DOptionsT>())).fused_activation_function
                            as *const _ as usize
                    },
                    12usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Conv2DOptionsT),
                        "::",
                        stringify!(fused_activation_function)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<Conv2DOptionsT>())).dilation_w_factor as *const _
                            as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Conv2DOptionsT),
                        "::",
                        stringify!(dilation_w_factor)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<Conv2DOptionsT>())).dilation_h_factor as *const _
                            as usize
                    },
                    20usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Conv2DOptionsT),
                        "::",
                        stringify!(dilation_h_factor)
                    )
                );
            }

            impl Default for Conv2DOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct Conv2DOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type Conv2DOptions_NativeTableType = root::tflite::Conv2DOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum Conv2DOptions_FlatBuffersVTableOffset {
                VT_PADDING = 4,
                VT_STRIDE_W = 6,
                VT_STRIDE_H = 8,
                VT_FUSED_ACTIVATION_FUNCTION = 10,
                VT_DILATION_W_FACTOR = 12,
                VT_DILATION_H_FACTOR = 14,
            }

            #[test]
            fn bindgen_test_layout_Conv2DOptions() {
                assert_eq!(
                    ::std::mem::size_of::<Conv2DOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(Conv2DOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<Conv2DOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(Conv2DOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct Pool2DOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub padding: root::tflite::Padding,
                pub stride_w: i32,
                pub stride_h: i32,
                pub filter_width: i32,
                pub filter_height: i32,
                pub fused_activation_function: root::tflite::ActivationFunctionType,
            }

            #[test]
            fn bindgen_test_layout_Pool2DOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<Pool2DOptionsT>(),
                    24usize,
                    concat!("Size of: ", stringify!(Pool2DOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<Pool2DOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(Pool2DOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<Pool2DOptionsT>())).padding as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Pool2DOptionsT),
                        "::",
                        stringify!(padding)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<Pool2DOptionsT>())).stride_w as *const _ as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Pool2DOptionsT),
                        "::",
                        stringify!(stride_w)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<Pool2DOptionsT>())).stride_h as *const _ as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Pool2DOptionsT),
                        "::",
                        stringify!(stride_h)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<Pool2DOptionsT>())).filter_width as *const _ as usize
                    },
                    12usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Pool2DOptionsT),
                        "::",
                        stringify!(filter_width)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<Pool2DOptionsT>())).filter_height as *const _
                            as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Pool2DOptionsT),
                        "::",
                        stringify!(filter_height)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<Pool2DOptionsT>())).fused_activation_function
                            as *const _ as usize
                    },
                    20usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(Pool2DOptionsT),
                        "::",
                        stringify!(fused_activation_function)
                    )
                );
            }

            impl Default for Pool2DOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct Pool2DOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type Pool2DOptions_NativeTableType = root::tflite::Pool2DOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum Pool2DOptions_FlatBuffersVTableOffset {
                VT_PADDING = 4,
                VT_STRIDE_W = 6,
                VT_STRIDE_H = 8,
                VT_FILTER_WIDTH = 10,
                VT_FILTER_HEIGHT = 12,
                VT_FUSED_ACTIVATION_FUNCTION = 14,
            }

            #[test]
            fn bindgen_test_layout_Pool2DOptions() {
                assert_eq!(
                    ::std::mem::size_of::<Pool2DOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(Pool2DOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<Pool2DOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(Pool2DOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct DepthwiseConv2DOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub padding: root::tflite::Padding,
                pub stride_w: i32,
                pub stride_h: i32,
                pub depth_multiplier: i32,
                pub fused_activation_function: root::tflite::ActivationFunctionType,
                pub dilation_w_factor: i32,
                pub dilation_h_factor: i32,
            }

            #[test]
            fn bindgen_test_layout_DepthwiseConv2DOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<DepthwiseConv2DOptionsT>(),
                    28usize,
                    concat!("Size of: ", stringify!(DepthwiseConv2DOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<DepthwiseConv2DOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(DepthwiseConv2DOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<DepthwiseConv2DOptionsT>())).padding as *const _
                            as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DepthwiseConv2DOptionsT),
                        "::",
                        stringify!(padding)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<DepthwiseConv2DOptionsT>())).stride_w as *const _
                            as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DepthwiseConv2DOptionsT),
                        "::",
                        stringify!(stride_w)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<DepthwiseConv2DOptionsT>())).stride_h as *const _
                            as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DepthwiseConv2DOptionsT),
                        "::",
                        stringify!(stride_h)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<DepthwiseConv2DOptionsT>())).depth_multiplier
                            as *const _ as usize
                    },
                    12usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DepthwiseConv2DOptionsT),
                        "::",
                        stringify!(depth_multiplier)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<DepthwiseConv2DOptionsT>()))
                            .fused_activation_function as *const _ as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DepthwiseConv2DOptionsT),
                        "::",
                        stringify!(fused_activation_function)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<DepthwiseConv2DOptionsT>())).dilation_w_factor
                            as *const _ as usize
                    },
                    20usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DepthwiseConv2DOptionsT),
                        "::",
                        stringify!(dilation_w_factor)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<DepthwiseConv2DOptionsT>())).dilation_h_factor
                            as *const _ as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DepthwiseConv2DOptionsT),
                        "::",
                        stringify!(dilation_h_factor)
                    )
                );
            }

            impl Default for DepthwiseConv2DOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct DepthwiseConv2DOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type DepthwiseConv2DOptions_NativeTableType = root::tflite::DepthwiseConv2DOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum DepthwiseConv2DOptions_FlatBuffersVTableOffset {
                VT_PADDING = 4,
                VT_STRIDE_W = 6,
                VT_STRIDE_H = 8,
                VT_DEPTH_MULTIPLIER = 10,
                VT_FUSED_ACTIVATION_FUNCTION = 12,
                VT_DILATION_W_FACTOR = 14,
                VT_DILATION_H_FACTOR = 16,
            }

            #[test]
            fn bindgen_test_layout_DepthwiseConv2DOptions() {
                assert_eq!(
                    ::std::mem::size_of::<DepthwiseConv2DOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(DepthwiseConv2DOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<DepthwiseConv2DOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(DepthwiseConv2DOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, PartialEq, Eq)]
            pub struct ConcatEmbeddingsOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub num_channels: i32,
                pub num_columns_per_channel: root::std::vector,
                pub embedding_dim_per_channel: root::std::vector,
            }

            #[test]
            fn bindgen_test_layout_ConcatEmbeddingsOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<ConcatEmbeddingsOptionsT>(),
                    56usize,
                    concat!("Size of: ", stringify!(ConcatEmbeddingsOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<ConcatEmbeddingsOptionsT>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ConcatEmbeddingsOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<ConcatEmbeddingsOptionsT>())).num_channels
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ConcatEmbeddingsOptionsT),
                        "::",
                        stringify!(num_channels)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<ConcatEmbeddingsOptionsT>())).num_columns_per_channel
                            as *const _ as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ConcatEmbeddingsOptionsT),
                        "::",
                        stringify!(num_columns_per_channel)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<ConcatEmbeddingsOptionsT>()))
                            .embedding_dim_per_channel as *const _ as usize
                    },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ConcatEmbeddingsOptionsT),
                        "::",
                        stringify!(embedding_dim_per_channel)
                    )
                );
            }

            impl Default for ConcatEmbeddingsOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ConcatEmbeddingsOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type ConcatEmbeddingsOptions_NativeTableType =
                root::tflite::ConcatEmbeddingsOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum ConcatEmbeddingsOptions_FlatBuffersVTableOffset {
                VT_NUM_CHANNELS = 4,
                VT_NUM_COLUMNS_PER_CHANNEL = 6,
                VT_EMBEDDING_DIM_PER_CHANNEL = 8,
            }

            #[test]
            fn bindgen_test_layout_ConcatEmbeddingsOptions() {
                assert_eq!(
                    ::std::mem::size_of::<ConcatEmbeddingsOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(ConcatEmbeddingsOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<ConcatEmbeddingsOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ConcatEmbeddingsOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct LSHProjectionOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub type_: root::tflite::LSHProjectionType,
            }

            #[test]
            fn bindgen_test_layout_LSHProjectionOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<LSHProjectionOptionsT>(),
                    4usize,
                    concat!("Size of: ", stringify!(LSHProjectionOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<LSHProjectionOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(LSHProjectionOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<LSHProjectionOptionsT>())).type_ as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(LSHProjectionOptionsT),
                        "::",
                        stringify!(type_)
                    )
                );
            }

            impl Default for LSHProjectionOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct LSHProjectionOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type LSHProjectionOptions_NativeTableType = root::tflite::LSHProjectionOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum LSHProjectionOptions_FlatBuffersVTableOffset {
                VT_TYPE = 4,
            }

            #[test]
            fn bindgen_test_layout_LSHProjectionOptions() {
                assert_eq!(
                    ::std::mem::size_of::<LSHProjectionOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(LSHProjectionOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<LSHProjectionOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(LSHProjectionOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct SVDFOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub rank: i32,
                pub fused_activation_function: root::tflite::ActivationFunctionType,
                pub asymmetric_quantize_inputs: bool,
            }

            #[test]
            fn bindgen_test_layout_SVDFOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<SVDFOptionsT>(),
                    12usize,
                    concat!("Size of: ", stringify!(SVDFOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<SVDFOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(SVDFOptionsT))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<SVDFOptionsT>())).rank as *const _ as usize },
                    0usize,
                    concat!("Offset of field: ", stringify!(SVDFOptionsT), "::", stringify!(rank))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SVDFOptionsT>())).fused_activation_function
                            as *const _ as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SVDFOptionsT),
                        "::",
                        stringify!(fused_activation_function)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SVDFOptionsT>())).asymmetric_quantize_inputs
                            as *const _ as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SVDFOptionsT),
                        "::",
                        stringify!(asymmetric_quantize_inputs)
                    )
                );
            }

            impl Default for SVDFOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SVDFOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type SVDFOptions_NativeTableType = root::tflite::SVDFOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum SVDFOptions_FlatBuffersVTableOffset {
                VT_RANK = 4,
                VT_FUSED_ACTIVATION_FUNCTION = 6,
                VT_ASYMMETRIC_QUANTIZE_INPUTS = 8,
            }

            #[test]
            fn bindgen_test_layout_SVDFOptions() {
                assert_eq!(
                    ::std::mem::size_of::<SVDFOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(SVDFOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<SVDFOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SVDFOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct RNNOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub fused_activation_function: root::tflite::ActivationFunctionType,
                pub asymmetric_quantize_inputs: bool,
            }

            #[test]
            fn bindgen_test_layout_RNNOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<RNNOptionsT>(),
                    8usize,
                    concat!("Size of: ", stringify!(RNNOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<RNNOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(RNNOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<RNNOptionsT>())).fused_activation_function
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(RNNOptionsT),
                        "::",
                        stringify!(fused_activation_function)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<RNNOptionsT>())).asymmetric_quantize_inputs
                            as *const _ as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(RNNOptionsT),
                        "::",
                        stringify!(asymmetric_quantize_inputs)
                    )
                );
            }

            impl Default for RNNOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct RNNOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type RNNOptions_NativeTableType = root::tflite::RNNOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum RNNOptions_FlatBuffersVTableOffset {
                VT_FUSED_ACTIVATION_FUNCTION = 4,
                VT_ASYMMETRIC_QUANTIZE_INPUTS = 6,
            }

            #[test]
            fn bindgen_test_layout_RNNOptions() {
                assert_eq!(
                    ::std::mem::size_of::<RNNOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(RNNOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<RNNOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(RNNOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct SequenceRNNOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub time_major: bool,
                pub fused_activation_function: root::tflite::ActivationFunctionType,
                pub asymmetric_quantize_inputs: bool,
            }

            #[test]
            fn bindgen_test_layout_SequenceRNNOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<SequenceRNNOptionsT>(),
                    12usize,
                    concat!("Size of: ", stringify!(SequenceRNNOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<SequenceRNNOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(SequenceRNNOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SequenceRNNOptionsT>())).time_major as *const _
                            as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SequenceRNNOptionsT),
                        "::",
                        stringify!(time_major)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SequenceRNNOptionsT>())).fused_activation_function
                            as *const _ as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SequenceRNNOptionsT),
                        "::",
                        stringify!(fused_activation_function)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SequenceRNNOptionsT>())).asymmetric_quantize_inputs
                            as *const _ as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SequenceRNNOptionsT),
                        "::",
                        stringify!(asymmetric_quantize_inputs)
                    )
                );
            }

            impl Default for SequenceRNNOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SequenceRNNOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type SequenceRNNOptions_NativeTableType = root::tflite::SequenceRNNOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum SequenceRNNOptions_FlatBuffersVTableOffset {
                VT_TIME_MAJOR = 4,
                VT_FUSED_ACTIVATION_FUNCTION = 6,
                VT_ASYMMETRIC_QUANTIZE_INPUTS = 8,
            }

            #[test]
            fn bindgen_test_layout_SequenceRNNOptions() {
                assert_eq!(
                    ::std::mem::size_of::<SequenceRNNOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(SequenceRNNOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<SequenceRNNOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SequenceRNNOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct BidirectionalSequenceRNNOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub time_major: bool,
                pub fused_activation_function: root::tflite::ActivationFunctionType,
                pub merge_outputs: bool,
                pub asymmetric_quantize_inputs: bool,
            }

            #[test]
            fn bindgen_test_layout_BidirectionalSequenceRNNOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<BidirectionalSequenceRNNOptionsT>(),
                    12usize,
                    concat!("Size of: ", stringify!(BidirectionalSequenceRNNOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<BidirectionalSequenceRNNOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(BidirectionalSequenceRNNOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<BidirectionalSequenceRNNOptionsT>())).time_major
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BidirectionalSequenceRNNOptionsT),
                        "::",
                        stringify!(time_major)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<BidirectionalSequenceRNNOptionsT>()))
                            .fused_activation_function as *const _ as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BidirectionalSequenceRNNOptionsT),
                        "::",
                        stringify!(fused_activation_function)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<BidirectionalSequenceRNNOptionsT>())).merge_outputs
                            as *const _ as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BidirectionalSequenceRNNOptionsT),
                        "::",
                        stringify!(merge_outputs)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<BidirectionalSequenceRNNOptionsT>()))
                            .asymmetric_quantize_inputs as *const _ as usize
                    },
                    9usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BidirectionalSequenceRNNOptionsT),
                        "::",
                        stringify!(asymmetric_quantize_inputs)
                    )
                );
            }

            impl Default for BidirectionalSequenceRNNOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct BidirectionalSequenceRNNOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type BidirectionalSequenceRNNOptions_NativeTableType =
                root::tflite::BidirectionalSequenceRNNOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum BidirectionalSequenceRNNOptions_FlatBuffersVTableOffset {
                VT_TIME_MAJOR = 4,
                VT_FUSED_ACTIVATION_FUNCTION = 6,
                VT_MERGE_OUTPUTS = 8,
                VT_ASYMMETRIC_QUANTIZE_INPUTS = 10,
            }

            #[test]
            fn bindgen_test_layout_BidirectionalSequenceRNNOptions() {
                assert_eq!(
                    ::std::mem::size_of::<BidirectionalSequenceRNNOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(BidirectionalSequenceRNNOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<BidirectionalSequenceRNNOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(BidirectionalSequenceRNNOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct FullyConnectedOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub fused_activation_function: root::tflite::ActivationFunctionType,
                pub weights_format: root::tflite::FullyConnectedOptionsWeightsFormat,
                pub keep_num_dims: bool,
                pub asymmetric_quantize_inputs: bool,
            }

            #[test]
            fn bindgen_test_layout_FullyConnectedOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<FullyConnectedOptionsT>(),
                    12usize,
                    concat!("Size of: ", stringify!(FullyConnectedOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<FullyConnectedOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(FullyConnectedOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<FullyConnectedOptionsT>())).fused_activation_function
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(FullyConnectedOptionsT),
                        "::",
                        stringify!(fused_activation_function)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<FullyConnectedOptionsT>())).weights_format
                            as *const _ as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(FullyConnectedOptionsT),
                        "::",
                        stringify!(weights_format)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<FullyConnectedOptionsT>())).keep_num_dims as *const _
                            as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(FullyConnectedOptionsT),
                        "::",
                        stringify!(keep_num_dims)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<FullyConnectedOptionsT>()))
                            .asymmetric_quantize_inputs as *const _ as usize
                    },
                    9usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(FullyConnectedOptionsT),
                        "::",
                        stringify!(asymmetric_quantize_inputs)
                    )
                );
            }

            impl Default for FullyConnectedOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct FullyConnectedOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type FullyConnectedOptions_NativeTableType = root::tflite::FullyConnectedOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum FullyConnectedOptions_FlatBuffersVTableOffset {
                VT_FUSED_ACTIVATION_FUNCTION = 4,
                VT_WEIGHTS_FORMAT = 6,
                VT_KEEP_NUM_DIMS = 8,
                VT_ASYMMETRIC_QUANTIZE_INPUTS = 10,
            }

            #[test]
            fn bindgen_test_layout_FullyConnectedOptions() {
                assert_eq!(
                    ::std::mem::size_of::<FullyConnectedOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(FullyConnectedOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<FullyConnectedOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(FullyConnectedOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq)]
            pub struct SoftmaxOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub beta: f32,
            }

            #[test]
            fn bindgen_test_layout_SoftmaxOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<SoftmaxOptionsT>(),
                    4usize,
                    concat!("Size of: ", stringify!(SoftmaxOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<SoftmaxOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(SoftmaxOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SoftmaxOptionsT>())).beta as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SoftmaxOptionsT),
                        "::",
                        stringify!(beta)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SoftmaxOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type SoftmaxOptions_NativeTableType = root::tflite::SoftmaxOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum SoftmaxOptions_FlatBuffersVTableOffset {
                VT_BETA = 4,
            }

            #[test]
            fn bindgen_test_layout_SoftmaxOptions() {
                assert_eq!(
                    ::std::mem::size_of::<SoftmaxOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(SoftmaxOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<SoftmaxOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SoftmaxOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct ConcatenationOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub axis: i32,
                pub fused_activation_function: root::tflite::ActivationFunctionType,
            }

            #[test]
            fn bindgen_test_layout_ConcatenationOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<ConcatenationOptionsT>(),
                    8usize,
                    concat!("Size of: ", stringify!(ConcatenationOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<ConcatenationOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(ConcatenationOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<ConcatenationOptionsT>())).axis as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ConcatenationOptionsT),
                        "::",
                        stringify!(axis)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<ConcatenationOptionsT>())).fused_activation_function
                            as *const _ as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ConcatenationOptionsT),
                        "::",
                        stringify!(fused_activation_function)
                    )
                );
            }

            impl Default for ConcatenationOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ConcatenationOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type ConcatenationOptions_NativeTableType = root::tflite::ConcatenationOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum ConcatenationOptions_FlatBuffersVTableOffset {
                VT_AXIS = 4,
                VT_FUSED_ACTIVATION_FUNCTION = 6,
            }

            #[test]
            fn bindgen_test_layout_ConcatenationOptions() {
                assert_eq!(
                    ::std::mem::size_of::<ConcatenationOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(ConcatenationOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<ConcatenationOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ConcatenationOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct AddOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub fused_activation_function: root::tflite::ActivationFunctionType,
                pub pot_scale_int16: bool,
            }

            #[test]
            fn bindgen_test_layout_AddOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<AddOptionsT>(),
                    8usize,
                    concat!("Size of: ", stringify!(AddOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<AddOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(AddOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<AddOptionsT>())).fused_activation_function
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AddOptionsT),
                        "::",
                        stringify!(fused_activation_function)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<AddOptionsT>())).pot_scale_int16 as *const _ as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(AddOptionsT),
                        "::",
                        stringify!(pot_scale_int16)
                    )
                );
            }

            impl Default for AddOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct AddOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type AddOptions_NativeTableType = root::tflite::AddOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum AddOptions_FlatBuffersVTableOffset {
                VT_FUSED_ACTIVATION_FUNCTION = 4,
                VT_POT_SCALE_INT16 = 6,
            }

            #[test]
            fn bindgen_test_layout_AddOptions() {
                assert_eq!(
                    ::std::mem::size_of::<AddOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(AddOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<AddOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(AddOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct MulOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub fused_activation_function: root::tflite::ActivationFunctionType,
            }

            #[test]
            fn bindgen_test_layout_MulOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<MulOptionsT>(),
                    4usize,
                    concat!("Size of: ", stringify!(MulOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<MulOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(MulOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<MulOptionsT>())).fused_activation_function
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MulOptionsT),
                        "::",
                        stringify!(fused_activation_function)
                    )
                );
            }

            impl Default for MulOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct MulOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type MulOptions_NativeTableType = root::tflite::MulOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum MulOptions_FlatBuffersVTableOffset {
                VT_FUSED_ACTIVATION_FUNCTION = 4,
            }

            #[test]
            fn bindgen_test_layout_MulOptions() {
                assert_eq!(
                    ::std::mem::size_of::<MulOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(MulOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<MulOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(MulOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct L2NormOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub fused_activation_function: root::tflite::ActivationFunctionType,
            }

            #[test]
            fn bindgen_test_layout_L2NormOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<L2NormOptionsT>(),
                    4usize,
                    concat!("Size of: ", stringify!(L2NormOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<L2NormOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(L2NormOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<L2NormOptionsT>())).fused_activation_function
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(L2NormOptionsT),
                        "::",
                        stringify!(fused_activation_function)
                    )
                );
            }

            impl Default for L2NormOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct L2NormOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type L2NormOptions_NativeTableType = root::tflite::L2NormOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum L2NormOptions_FlatBuffersVTableOffset {
                VT_FUSED_ACTIVATION_FUNCTION = 4,
            }

            #[test]
            fn bindgen_test_layout_L2NormOptions() {
                assert_eq!(
                    ::std::mem::size_of::<L2NormOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(L2NormOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<L2NormOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(L2NormOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq)]
            pub struct LocalResponseNormalizationOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub radius: i32,
                pub bias: f32,
                pub alpha: f32,
                pub beta: f32,
            }

            #[test]
            fn bindgen_test_layout_LocalResponseNormalizationOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<LocalResponseNormalizationOptionsT>(),
                    16usize,
                    concat!("Size of: ", stringify!(LocalResponseNormalizationOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<LocalResponseNormalizationOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(LocalResponseNormalizationOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<LocalResponseNormalizationOptionsT>())).radius
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(LocalResponseNormalizationOptionsT),
                        "::",
                        stringify!(radius)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<LocalResponseNormalizationOptionsT>())).bias
                            as *const _ as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(LocalResponseNormalizationOptionsT),
                        "::",
                        stringify!(bias)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<LocalResponseNormalizationOptionsT>())).alpha
                            as *const _ as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(LocalResponseNormalizationOptionsT),
                        "::",
                        stringify!(alpha)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<LocalResponseNormalizationOptionsT>())).beta
                            as *const _ as usize
                    },
                    12usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(LocalResponseNormalizationOptionsT),
                        "::",
                        stringify!(beta)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct LocalResponseNormalizationOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type LocalResponseNormalizationOptions_NativeTableType =
                root::tflite::LocalResponseNormalizationOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum LocalResponseNormalizationOptions_FlatBuffersVTableOffset {
                VT_RADIUS = 4,
                VT_BIAS = 6,
                VT_ALPHA = 8,
                VT_BETA = 10,
            }

            #[test]
            fn bindgen_test_layout_LocalResponseNormalizationOptions() {
                assert_eq!(
                    ::std::mem::size_of::<LocalResponseNormalizationOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(LocalResponseNormalizationOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<LocalResponseNormalizationOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(LocalResponseNormalizationOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct LSTMOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub fused_activation_function: root::tflite::ActivationFunctionType,
                pub cell_clip: f32,
                pub proj_clip: f32,
                pub kernel_type: root::tflite::LSTMKernelType,
                pub asymmetric_quantize_inputs: bool,
            }

            #[test]
            fn bindgen_test_layout_LSTMOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<LSTMOptionsT>(),
                    20usize,
                    concat!("Size of: ", stringify!(LSTMOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<LSTMOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(LSTMOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<LSTMOptionsT>())).fused_activation_function
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(LSTMOptionsT),
                        "::",
                        stringify!(fused_activation_function)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<LSTMOptionsT>())).cell_clip as *const _ as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(LSTMOptionsT),
                        "::",
                        stringify!(cell_clip)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<LSTMOptionsT>())).proj_clip as *const _ as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(LSTMOptionsT),
                        "::",
                        stringify!(proj_clip)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<LSTMOptionsT>())).kernel_type as *const _ as usize
                    },
                    12usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(LSTMOptionsT),
                        "::",
                        stringify!(kernel_type)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<LSTMOptionsT>())).asymmetric_quantize_inputs
                            as *const _ as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(LSTMOptionsT),
                        "::",
                        stringify!(asymmetric_quantize_inputs)
                    )
                );
            }

            impl Default for LSTMOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct LSTMOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type LSTMOptions_NativeTableType = root::tflite::LSTMOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum LSTMOptions_FlatBuffersVTableOffset {
                VT_FUSED_ACTIVATION_FUNCTION = 4,
                VT_CELL_CLIP = 6,
                VT_PROJ_CLIP = 8,
                VT_KERNEL_TYPE = 10,
                VT_ASYMMETRIC_QUANTIZE_INPUTS = 12,
            }

            #[test]
            fn bindgen_test_layout_LSTMOptions() {
                assert_eq!(
                    ::std::mem::size_of::<LSTMOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(LSTMOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<LSTMOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(LSTMOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct UnidirectionalSequenceLSTMOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub fused_activation_function: root::tflite::ActivationFunctionType,
                pub cell_clip: f32,
                pub proj_clip: f32,
                pub time_major: bool,
                pub asymmetric_quantize_inputs: bool,
            }

            #[test]
            fn bindgen_test_layout_UnidirectionalSequenceLSTMOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<UnidirectionalSequenceLSTMOptionsT>(),
                    16usize,
                    concat!("Size of: ", stringify!(UnidirectionalSequenceLSTMOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<UnidirectionalSequenceLSTMOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(UnidirectionalSequenceLSTMOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<UnidirectionalSequenceLSTMOptionsT>()))
                            .fused_activation_function as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(UnidirectionalSequenceLSTMOptionsT),
                        "::",
                        stringify!(fused_activation_function)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<UnidirectionalSequenceLSTMOptionsT>())).cell_clip
                            as *const _ as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(UnidirectionalSequenceLSTMOptionsT),
                        "::",
                        stringify!(cell_clip)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<UnidirectionalSequenceLSTMOptionsT>())).proj_clip
                            as *const _ as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(UnidirectionalSequenceLSTMOptionsT),
                        "::",
                        stringify!(proj_clip)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<UnidirectionalSequenceLSTMOptionsT>())).time_major
                            as *const _ as usize
                    },
                    12usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(UnidirectionalSequenceLSTMOptionsT),
                        "::",
                        stringify!(time_major)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<UnidirectionalSequenceLSTMOptionsT>()))
                            .asymmetric_quantize_inputs as *const _ as usize
                    },
                    13usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(UnidirectionalSequenceLSTMOptionsT),
                        "::",
                        stringify!(asymmetric_quantize_inputs)
                    )
                );
            }

            impl Default for UnidirectionalSequenceLSTMOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct UnidirectionalSequenceLSTMOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type UnidirectionalSequenceLSTMOptions_NativeTableType =
                root::tflite::UnidirectionalSequenceLSTMOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum UnidirectionalSequenceLSTMOptions_FlatBuffersVTableOffset {
                VT_FUSED_ACTIVATION_FUNCTION = 4,
                VT_CELL_CLIP = 6,
                VT_PROJ_CLIP = 8,
                VT_TIME_MAJOR = 10,
                VT_ASYMMETRIC_QUANTIZE_INPUTS = 12,
            }

            #[test]
            fn bindgen_test_layout_UnidirectionalSequenceLSTMOptions() {
                assert_eq!(
                    ::std::mem::size_of::<UnidirectionalSequenceLSTMOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(UnidirectionalSequenceLSTMOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<UnidirectionalSequenceLSTMOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(UnidirectionalSequenceLSTMOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq)]
            pub struct BidirectionalSequenceLSTMOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub fused_activation_function: root::tflite::ActivationFunctionType,
                pub cell_clip: f32,
                pub proj_clip: f32,
                pub merge_outputs: bool,
                pub time_major: bool,
                pub asymmetric_quantize_inputs: bool,
            }

            #[test]
            fn bindgen_test_layout_BidirectionalSequenceLSTMOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<BidirectionalSequenceLSTMOptionsT>(),
                    16usize,
                    concat!("Size of: ", stringify!(BidirectionalSequenceLSTMOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<BidirectionalSequenceLSTMOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(BidirectionalSequenceLSTMOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<BidirectionalSequenceLSTMOptionsT>()))
                            .fused_activation_function as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BidirectionalSequenceLSTMOptionsT),
                        "::",
                        stringify!(fused_activation_function)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<BidirectionalSequenceLSTMOptionsT>())).cell_clip
                            as *const _ as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BidirectionalSequenceLSTMOptionsT),
                        "::",
                        stringify!(cell_clip)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<BidirectionalSequenceLSTMOptionsT>())).proj_clip
                            as *const _ as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BidirectionalSequenceLSTMOptionsT),
                        "::",
                        stringify!(proj_clip)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<BidirectionalSequenceLSTMOptionsT>())).merge_outputs
                            as *const _ as usize
                    },
                    12usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BidirectionalSequenceLSTMOptionsT),
                        "::",
                        stringify!(merge_outputs)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<BidirectionalSequenceLSTMOptionsT>())).time_major
                            as *const _ as usize
                    },
                    13usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BidirectionalSequenceLSTMOptionsT),
                        "::",
                        stringify!(time_major)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<BidirectionalSequenceLSTMOptionsT>()))
                            .asymmetric_quantize_inputs as *const _ as usize
                    },
                    14usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BidirectionalSequenceLSTMOptionsT),
                        "::",
                        stringify!(asymmetric_quantize_inputs)
                    )
                );
            }

            impl Default for BidirectionalSequenceLSTMOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct BidirectionalSequenceLSTMOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type BidirectionalSequenceLSTMOptions_NativeTableType =
                root::tflite::BidirectionalSequenceLSTMOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum BidirectionalSequenceLSTMOptions_FlatBuffersVTableOffset {
                VT_FUSED_ACTIVATION_FUNCTION = 4,
                VT_CELL_CLIP = 6,
                VT_PROJ_CLIP = 8,
                VT_MERGE_OUTPUTS = 10,
                VT_TIME_MAJOR = 12,
                VT_ASYMMETRIC_QUANTIZE_INPUTS = 14,
            }

            #[test]
            fn bindgen_test_layout_BidirectionalSequenceLSTMOptions() {
                assert_eq!(
                    ::std::mem::size_of::<BidirectionalSequenceLSTMOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(BidirectionalSequenceLSTMOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<BidirectionalSequenceLSTMOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(BidirectionalSequenceLSTMOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ResizeBilinearOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub align_corners: bool,
                pub half_pixel_centers: bool,
            }

            #[test]
            fn bindgen_test_layout_ResizeBilinearOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<ResizeBilinearOptionsT>(),
                    2usize,
                    concat!("Size of: ", stringify!(ResizeBilinearOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<ResizeBilinearOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ResizeBilinearOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<ResizeBilinearOptionsT>())).align_corners as *const _
                            as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ResizeBilinearOptionsT),
                        "::",
                        stringify!(align_corners)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<ResizeBilinearOptionsT>())).half_pixel_centers
                            as *const _ as usize
                    },
                    1usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ResizeBilinearOptionsT),
                        "::",
                        stringify!(half_pixel_centers)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ResizeBilinearOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type ResizeBilinearOptions_NativeTableType = root::tflite::ResizeBilinearOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum ResizeBilinearOptions_FlatBuffersVTableOffset {
                VT_ALIGN_CORNERS = 8,
                VT_HALF_PIXEL_CENTERS = 10,
            }

            #[test]
            fn bindgen_test_layout_ResizeBilinearOptions() {
                assert_eq!(
                    ::std::mem::size_of::<ResizeBilinearOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(ResizeBilinearOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<ResizeBilinearOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ResizeBilinearOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ResizeNearestNeighborOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub align_corners: bool,
                pub half_pixel_centers: bool,
            }

            #[test]
            fn bindgen_test_layout_ResizeNearestNeighborOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<ResizeNearestNeighborOptionsT>(),
                    2usize,
                    concat!("Size of: ", stringify!(ResizeNearestNeighborOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<ResizeNearestNeighborOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ResizeNearestNeighborOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<ResizeNearestNeighborOptionsT>())).align_corners
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ResizeNearestNeighborOptionsT),
                        "::",
                        stringify!(align_corners)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<ResizeNearestNeighborOptionsT>())).half_pixel_centers
                            as *const _ as usize
                    },
                    1usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ResizeNearestNeighborOptionsT),
                        "::",
                        stringify!(half_pixel_centers)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ResizeNearestNeighborOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type ResizeNearestNeighborOptions_NativeTableType =
                root::tflite::ResizeNearestNeighborOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum ResizeNearestNeighborOptions_FlatBuffersVTableOffset {
                VT_ALIGN_CORNERS = 4,
                VT_HALF_PIXEL_CENTERS = 6,
            }

            #[test]
            fn bindgen_test_layout_ResizeNearestNeighborOptions() {
                assert_eq!(
                    ::std::mem::size_of::<ResizeNearestNeighborOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(ResizeNearestNeighborOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<ResizeNearestNeighborOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ResizeNearestNeighborOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct CallOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub subgraph: u32,
            }

            #[test]
            fn bindgen_test_layout_CallOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<CallOptionsT>(),
                    4usize,
                    concat!("Size of: ", stringify!(CallOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<CallOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(CallOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<CallOptionsT>())).subgraph as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CallOptionsT),
                        "::",
                        stringify!(subgraph)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct CallOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type CallOptions_NativeTableType = root::tflite::CallOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum CallOptions_FlatBuffersVTableOffset {
                VT_SUBGRAPH = 4,
            }

            #[test]
            fn bindgen_test_layout_CallOptions() {
                assert_eq!(
                    ::std::mem::size_of::<CallOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(CallOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<CallOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(CallOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct PadOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_PadOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<PadOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(PadOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<PadOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(PadOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct PadOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type PadOptions_NativeTableType = root::tflite::PadOptionsT;

            #[test]
            fn bindgen_test_layout_PadOptions() {
                assert_eq!(
                    ::std::mem::size_of::<PadOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(PadOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<PadOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(PadOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct PadV2OptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_PadV2OptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<PadV2OptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(PadV2OptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<PadV2OptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(PadV2OptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct PadV2Options {
                pub _base: root::flatbuffers::Table,
            }

            pub type PadV2Options_NativeTableType = root::tflite::PadV2OptionsT;

            #[test]
            fn bindgen_test_layout_PadV2Options() {
                assert_eq!(
                    ::std::mem::size_of::<PadV2Options>(),
                    1usize,
                    concat!("Size of: ", stringify!(PadV2Options))
                );
                assert_eq!(
                    ::std::mem::align_of::<PadV2Options>(),
                    1usize,
                    concat!("Alignment of ", stringify!(PadV2Options))
                );
            }

            #[repr(C)]
            #[derive(Debug, PartialEq, Eq)]
            pub struct ReshapeOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub new_shape: root::std::vector,
            }

            #[test]
            fn bindgen_test_layout_ReshapeOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<ReshapeOptionsT>(),
                    24usize,
                    concat!("Size of: ", stringify!(ReshapeOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<ReshapeOptionsT>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ReshapeOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<ReshapeOptionsT>())).new_shape as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ReshapeOptionsT),
                        "::",
                        stringify!(new_shape)
                    )
                );
            }

            impl Default for ReshapeOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ReshapeOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type ReshapeOptions_NativeTableType = root::tflite::ReshapeOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum ReshapeOptions_FlatBuffersVTableOffset {
                VT_NEW_SHAPE = 4,
            }

            #[test]
            fn bindgen_test_layout_ReshapeOptions() {
                assert_eq!(
                    ::std::mem::size_of::<ReshapeOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(ReshapeOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<ReshapeOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ReshapeOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SpaceToBatchNDOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_SpaceToBatchNDOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<SpaceToBatchNDOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(SpaceToBatchNDOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<SpaceToBatchNDOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SpaceToBatchNDOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SpaceToBatchNDOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type SpaceToBatchNDOptions_NativeTableType = root::tflite::SpaceToBatchNDOptionsT;

            #[test]
            fn bindgen_test_layout_SpaceToBatchNDOptions() {
                assert_eq!(
                    ::std::mem::size_of::<SpaceToBatchNDOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(SpaceToBatchNDOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<SpaceToBatchNDOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SpaceToBatchNDOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct BatchToSpaceNDOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_BatchToSpaceNDOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<BatchToSpaceNDOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(BatchToSpaceNDOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<BatchToSpaceNDOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(BatchToSpaceNDOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct BatchToSpaceNDOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type BatchToSpaceNDOptions_NativeTableType = root::tflite::BatchToSpaceNDOptionsT;

            #[test]
            fn bindgen_test_layout_BatchToSpaceNDOptions() {
                assert_eq!(
                    ::std::mem::size_of::<BatchToSpaceNDOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(BatchToSpaceNDOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<BatchToSpaceNDOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(BatchToSpaceNDOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SkipGramOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub ngram_size: i32,
                pub max_skip_size: i32,
                pub include_all_ngrams: bool,
            }

            #[test]
            fn bindgen_test_layout_SkipGramOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<SkipGramOptionsT>(),
                    12usize,
                    concat!("Size of: ", stringify!(SkipGramOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<SkipGramOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(SkipGramOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SkipGramOptionsT>())).ngram_size as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SkipGramOptionsT),
                        "::",
                        stringify!(ngram_size)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SkipGramOptionsT>())).max_skip_size as *const _
                            as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SkipGramOptionsT),
                        "::",
                        stringify!(max_skip_size)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SkipGramOptionsT>())).include_all_ngrams as *const _
                            as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SkipGramOptionsT),
                        "::",
                        stringify!(include_all_ngrams)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SkipGramOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type SkipGramOptions_NativeTableType = root::tflite::SkipGramOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum SkipGramOptions_FlatBuffersVTableOffset {
                VT_NGRAM_SIZE = 4,
                VT_MAX_SKIP_SIZE = 6,
                VT_INCLUDE_ALL_NGRAMS = 8,
            }

            #[test]
            fn bindgen_test_layout_SkipGramOptions() {
                assert_eq!(
                    ::std::mem::size_of::<SkipGramOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(SkipGramOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<SkipGramOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SkipGramOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SpaceToDepthOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub block_size: i32,
            }

            #[test]
            fn bindgen_test_layout_SpaceToDepthOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<SpaceToDepthOptionsT>(),
                    4usize,
                    concat!("Size of: ", stringify!(SpaceToDepthOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<SpaceToDepthOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(SpaceToDepthOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SpaceToDepthOptionsT>())).block_size as *const _
                            as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SpaceToDepthOptionsT),
                        "::",
                        stringify!(block_size)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SpaceToDepthOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type SpaceToDepthOptions_NativeTableType = root::tflite::SpaceToDepthOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum SpaceToDepthOptions_FlatBuffersVTableOffset {
                VT_BLOCK_SIZE = 4,
            }

            #[test]
            fn bindgen_test_layout_SpaceToDepthOptions() {
                assert_eq!(
                    ::std::mem::size_of::<SpaceToDepthOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(SpaceToDepthOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<SpaceToDepthOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SpaceToDepthOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct DepthToSpaceOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub block_size: i32,
            }

            #[test]
            fn bindgen_test_layout_DepthToSpaceOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<DepthToSpaceOptionsT>(),
                    4usize,
                    concat!("Size of: ", stringify!(DepthToSpaceOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<DepthToSpaceOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(DepthToSpaceOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<DepthToSpaceOptionsT>())).block_size as *const _
                            as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DepthToSpaceOptionsT),
                        "::",
                        stringify!(block_size)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct DepthToSpaceOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type DepthToSpaceOptions_NativeTableType = root::tflite::DepthToSpaceOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum DepthToSpaceOptions_FlatBuffersVTableOffset {
                VT_BLOCK_SIZE = 4,
            }

            #[test]
            fn bindgen_test_layout_DepthToSpaceOptions() {
                assert_eq!(
                    ::std::mem::size_of::<DepthToSpaceOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(DepthToSpaceOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<DepthToSpaceOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(DepthToSpaceOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct SubOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub fused_activation_function: root::tflite::ActivationFunctionType,
                pub pot_scale_int16: bool,
            }

            #[test]
            fn bindgen_test_layout_SubOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<SubOptionsT>(),
                    8usize,
                    concat!("Size of: ", stringify!(SubOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<SubOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(SubOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SubOptionsT>())).fused_activation_function
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SubOptionsT),
                        "::",
                        stringify!(fused_activation_function)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SubOptionsT>())).pot_scale_int16 as *const _ as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SubOptionsT),
                        "::",
                        stringify!(pot_scale_int16)
                    )
                );
            }

            impl Default for SubOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SubOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type SubOptions_NativeTableType = root::tflite::SubOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum SubOptions_FlatBuffersVTableOffset {
                VT_FUSED_ACTIVATION_FUNCTION = 4,
                VT_POT_SCALE_INT16 = 6,
            }

            #[test]
            fn bindgen_test_layout_SubOptions() {
                assert_eq!(
                    ::std::mem::size_of::<SubOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(SubOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<SubOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SubOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct DivOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub fused_activation_function: root::tflite::ActivationFunctionType,
            }

            #[test]
            fn bindgen_test_layout_DivOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<DivOptionsT>(),
                    4usize,
                    concat!("Size of: ", stringify!(DivOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<DivOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(DivOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<DivOptionsT>())).fused_activation_function
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(DivOptionsT),
                        "::",
                        stringify!(fused_activation_function)
                    )
                );
            }

            impl Default for DivOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct DivOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type DivOptions_NativeTableType = root::tflite::DivOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum DivOptions_FlatBuffersVTableOffset {
                VT_FUSED_ACTIVATION_FUNCTION = 4,
            }

            #[test]
            fn bindgen_test_layout_DivOptions() {
                assert_eq!(
                    ::std::mem::size_of::<DivOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(DivOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<DivOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(DivOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct TopKV2OptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_TopKV2OptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<TopKV2OptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(TopKV2OptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<TopKV2OptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(TopKV2OptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct TopKV2Options {
                pub _base: root::flatbuffers::Table,
            }

            pub type TopKV2Options_NativeTableType = root::tflite::TopKV2OptionsT;

            #[test]
            fn bindgen_test_layout_TopKV2Options() {
                assert_eq!(
                    ::std::mem::size_of::<TopKV2Options>(),
                    1usize,
                    concat!("Size of: ", stringify!(TopKV2Options))
                );
                assert_eq!(
                    ::std::mem::align_of::<TopKV2Options>(),
                    1usize,
                    concat!("Alignment of ", stringify!(TopKV2Options))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct EmbeddingLookupSparseOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub combiner: root::tflite::CombinerType,
            }

            #[test]
            fn bindgen_test_layout_EmbeddingLookupSparseOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<EmbeddingLookupSparseOptionsT>(),
                    4usize,
                    concat!("Size of: ", stringify!(EmbeddingLookupSparseOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<EmbeddingLookupSparseOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(EmbeddingLookupSparseOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<EmbeddingLookupSparseOptionsT>())).combiner
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(EmbeddingLookupSparseOptionsT),
                        "::",
                        stringify!(combiner)
                    )
                );
            }

            impl Default for EmbeddingLookupSparseOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct EmbeddingLookupSparseOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type EmbeddingLookupSparseOptions_NativeTableType =
                root::tflite::EmbeddingLookupSparseOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum EmbeddingLookupSparseOptions_FlatBuffersVTableOffset {
                VT_COMBINER = 4,
            }

            #[test]
            fn bindgen_test_layout_EmbeddingLookupSparseOptions() {
                assert_eq!(
                    ::std::mem::size_of::<EmbeddingLookupSparseOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(EmbeddingLookupSparseOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<EmbeddingLookupSparseOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(EmbeddingLookupSparseOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct GatherOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub axis: i32,
            }

            #[test]
            fn bindgen_test_layout_GatherOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<GatherOptionsT>(),
                    4usize,
                    concat!("Size of: ", stringify!(GatherOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<GatherOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(GatherOptionsT))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<GatherOptionsT>())).axis as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(GatherOptionsT),
                        "::",
                        stringify!(axis)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct GatherOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type GatherOptions_NativeTableType = root::tflite::GatherOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum GatherOptions_FlatBuffersVTableOffset {
                VT_AXIS = 4,
            }

            #[test]
            fn bindgen_test_layout_GatherOptions() {
                assert_eq!(
                    ::std::mem::size_of::<GatherOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(GatherOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<GatherOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(GatherOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct TransposeOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_TransposeOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<TransposeOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(TransposeOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<TransposeOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(TransposeOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct TransposeOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type TransposeOptions_NativeTableType = root::tflite::TransposeOptionsT;

            #[test]
            fn bindgen_test_layout_TransposeOptions() {
                assert_eq!(
                    ::std::mem::size_of::<TransposeOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(TransposeOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<TransposeOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(TransposeOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ExpOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_ExpOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<ExpOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(ExpOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<ExpOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ExpOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ExpOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type ExpOptions_NativeTableType = root::tflite::ExpOptionsT;

            #[test]
            fn bindgen_test_layout_ExpOptions() {
                assert_eq!(
                    ::std::mem::size_of::<ExpOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(ExpOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<ExpOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ExpOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct CosOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_CosOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<CosOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(CosOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<CosOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(CosOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct CosOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type CosOptions_NativeTableType = root::tflite::CosOptionsT;

            #[test]
            fn bindgen_test_layout_CosOptions() {
                assert_eq!(
                    ::std::mem::size_of::<CosOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(CosOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<CosOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(CosOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ReducerOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub keep_dims: bool,
            }

            #[test]
            fn bindgen_test_layout_ReducerOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<ReducerOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(ReducerOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<ReducerOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ReducerOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<ReducerOptionsT>())).keep_dims as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ReducerOptionsT),
                        "::",
                        stringify!(keep_dims)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ReducerOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type ReducerOptions_NativeTableType = root::tflite::ReducerOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum ReducerOptions_FlatBuffersVTableOffset {
                VT_KEEP_DIMS = 4,
            }

            #[test]
            fn bindgen_test_layout_ReducerOptions() {
                assert_eq!(
                    ::std::mem::size_of::<ReducerOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(ReducerOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<ReducerOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ReducerOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, PartialEq, Eq)]
            pub struct SqueezeOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub squeeze_dims: root::std::vector,
            }

            #[test]
            fn bindgen_test_layout_SqueezeOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<SqueezeOptionsT>(),
                    24usize,
                    concat!("Size of: ", stringify!(SqueezeOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<SqueezeOptionsT>(),
                    8usize,
                    concat!("Alignment of ", stringify!(SqueezeOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SqueezeOptionsT>())).squeeze_dims as *const _
                            as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SqueezeOptionsT),
                        "::",
                        stringify!(squeeze_dims)
                    )
                );
            }

            impl Default for SqueezeOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SqueezeOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type SqueezeOptions_NativeTableType = root::tflite::SqueezeOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum SqueezeOptions_FlatBuffersVTableOffset {
                VT_SQUEEZE_DIMS = 4,
            }

            #[test]
            fn bindgen_test_layout_SqueezeOptions() {
                assert_eq!(
                    ::std::mem::size_of::<SqueezeOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(SqueezeOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<SqueezeOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SqueezeOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SplitOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub num_splits: i32,
            }

            #[test]
            fn bindgen_test_layout_SplitOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<SplitOptionsT>(),
                    4usize,
                    concat!("Size of: ", stringify!(SplitOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<SplitOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(SplitOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SplitOptionsT>())).num_splits as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SplitOptionsT),
                        "::",
                        stringify!(num_splits)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SplitOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type SplitOptions_NativeTableType = root::tflite::SplitOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum SplitOptions_FlatBuffersVTableOffset {
                VT_NUM_SPLITS = 4,
            }

            #[test]
            fn bindgen_test_layout_SplitOptions() {
                assert_eq!(
                    ::std::mem::size_of::<SplitOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(SplitOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<SplitOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SplitOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SplitVOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub num_splits: i32,
            }

            #[test]
            fn bindgen_test_layout_SplitVOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<SplitVOptionsT>(),
                    4usize,
                    concat!("Size of: ", stringify!(SplitVOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<SplitVOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(SplitVOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SplitVOptionsT>())).num_splits as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SplitVOptionsT),
                        "::",
                        stringify!(num_splits)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SplitVOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type SplitVOptions_NativeTableType = root::tflite::SplitVOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum SplitVOptions_FlatBuffersVTableOffset {
                VT_NUM_SPLITS = 4,
            }

            #[test]
            fn bindgen_test_layout_SplitVOptions() {
                assert_eq!(
                    ::std::mem::size_of::<SplitVOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(SplitVOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<SplitVOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SplitVOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct StridedSliceOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub begin_mask: i32,
                pub end_mask: i32,
                pub ellipsis_mask: i32,
                pub new_axis_mask: i32,
                pub shrink_axis_mask: i32,
            }

            #[test]
            fn bindgen_test_layout_StridedSliceOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<StridedSliceOptionsT>(),
                    20usize,
                    concat!("Size of: ", stringify!(StridedSliceOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<StridedSliceOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(StridedSliceOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<StridedSliceOptionsT>())).begin_mask as *const _
                            as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(StridedSliceOptionsT),
                        "::",
                        stringify!(begin_mask)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<StridedSliceOptionsT>())).end_mask as *const _
                            as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(StridedSliceOptionsT),
                        "::",
                        stringify!(end_mask)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<StridedSliceOptionsT>())).ellipsis_mask as *const _
                            as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(StridedSliceOptionsT),
                        "::",
                        stringify!(ellipsis_mask)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<StridedSliceOptionsT>())).new_axis_mask as *const _
                            as usize
                    },
                    12usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(StridedSliceOptionsT),
                        "::",
                        stringify!(new_axis_mask)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<StridedSliceOptionsT>())).shrink_axis_mask
                            as *const _ as usize
                    },
                    16usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(StridedSliceOptionsT),
                        "::",
                        stringify!(shrink_axis_mask)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct StridedSliceOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type StridedSliceOptions_NativeTableType = root::tflite::StridedSliceOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum StridedSliceOptions_FlatBuffersVTableOffset {
                VT_BEGIN_MASK = 4,
                VT_END_MASK = 6,
                VT_ELLIPSIS_MASK = 8,
                VT_NEW_AXIS_MASK = 10,
                VT_SHRINK_AXIS_MASK = 12,
            }

            #[test]
            fn bindgen_test_layout_StridedSliceOptions() {
                assert_eq!(
                    ::std::mem::size_of::<StridedSliceOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(StridedSliceOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<StridedSliceOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(StridedSliceOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct LogSoftmaxOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_LogSoftmaxOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<LogSoftmaxOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(LogSoftmaxOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<LogSoftmaxOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(LogSoftmaxOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct LogSoftmaxOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type LogSoftmaxOptions_NativeTableType = root::tflite::LogSoftmaxOptionsT;

            #[test]
            fn bindgen_test_layout_LogSoftmaxOptions() {
                assert_eq!(
                    ::std::mem::size_of::<LogSoftmaxOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(LogSoftmaxOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<LogSoftmaxOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(LogSoftmaxOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct CastOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub in_data_type: root::tflite::TensorType,
                pub out_data_type: root::tflite::TensorType,
            }

            #[test]
            fn bindgen_test_layout_CastOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<CastOptionsT>(),
                    8usize,
                    concat!("Size of: ", stringify!(CastOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<CastOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(CastOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<CastOptionsT>())).in_data_type as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CastOptionsT),
                        "::",
                        stringify!(in_data_type)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<CastOptionsT>())).out_data_type as *const _ as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CastOptionsT),
                        "::",
                        stringify!(out_data_type)
                    )
                );
            }

            impl Default for CastOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct CastOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type CastOptions_NativeTableType = root::tflite::CastOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum CastOptions_FlatBuffersVTableOffset {
                VT_IN_DATA_TYPE = 4,
                VT_OUT_DATA_TYPE = 6,
            }

            #[test]
            fn bindgen_test_layout_CastOptions() {
                assert_eq!(
                    ::std::mem::size_of::<CastOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(CastOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<CastOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(CastOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct DequantizeOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_DequantizeOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<DequantizeOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(DequantizeOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<DequantizeOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(DequantizeOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct DequantizeOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type DequantizeOptions_NativeTableType = root::tflite::DequantizeOptionsT;

            #[test]
            fn bindgen_test_layout_DequantizeOptions() {
                assert_eq!(
                    ::std::mem::size_of::<DequantizeOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(DequantizeOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<DequantizeOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(DequantizeOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct MaximumMinimumOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_MaximumMinimumOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<MaximumMinimumOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(MaximumMinimumOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<MaximumMinimumOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(MaximumMinimumOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct MaximumMinimumOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type MaximumMinimumOptions_NativeTableType = root::tflite::MaximumMinimumOptionsT;

            #[test]
            fn bindgen_test_layout_MaximumMinimumOptions() {
                assert_eq!(
                    ::std::mem::size_of::<MaximumMinimumOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(MaximumMinimumOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<MaximumMinimumOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(MaximumMinimumOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct TileOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_TileOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<TileOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(TileOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<TileOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(TileOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct TileOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type TileOptions_NativeTableType = root::tflite::TileOptionsT;

            #[test]
            fn bindgen_test_layout_TileOptions() {
                assert_eq!(
                    ::std::mem::size_of::<TileOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(TileOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<TileOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(TileOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct ArgMaxOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub output_type: root::tflite::TensorType,
            }

            #[test]
            fn bindgen_test_layout_ArgMaxOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<ArgMaxOptionsT>(),
                    4usize,
                    concat!("Size of: ", stringify!(ArgMaxOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<ArgMaxOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(ArgMaxOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<ArgMaxOptionsT>())).output_type as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ArgMaxOptionsT),
                        "::",
                        stringify!(output_type)
                    )
                );
            }

            impl Default for ArgMaxOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ArgMaxOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type ArgMaxOptions_NativeTableType = root::tflite::ArgMaxOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum ArgMaxOptions_FlatBuffersVTableOffset {
                VT_OUTPUT_TYPE = 4,
            }

            #[test]
            fn bindgen_test_layout_ArgMaxOptions() {
                assert_eq!(
                    ::std::mem::size_of::<ArgMaxOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(ArgMaxOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<ArgMaxOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ArgMaxOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct ArgMinOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub output_type: root::tflite::TensorType,
            }

            #[test]
            fn bindgen_test_layout_ArgMinOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<ArgMinOptionsT>(),
                    4usize,
                    concat!("Size of: ", stringify!(ArgMinOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<ArgMinOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(ArgMinOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<ArgMinOptionsT>())).output_type as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ArgMinOptionsT),
                        "::",
                        stringify!(output_type)
                    )
                );
            }

            impl Default for ArgMinOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ArgMinOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type ArgMinOptions_NativeTableType = root::tflite::ArgMinOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum ArgMinOptions_FlatBuffersVTableOffset {
                VT_OUTPUT_TYPE = 4,
            }

            #[test]
            fn bindgen_test_layout_ArgMinOptions() {
                assert_eq!(
                    ::std::mem::size_of::<ArgMinOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(ArgMinOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<ArgMinOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ArgMinOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct GreaterOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_GreaterOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<GreaterOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(GreaterOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<GreaterOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(GreaterOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct GreaterOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type GreaterOptions_NativeTableType = root::tflite::GreaterOptionsT;

            #[test]
            fn bindgen_test_layout_GreaterOptions() {
                assert_eq!(
                    ::std::mem::size_of::<GreaterOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(GreaterOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<GreaterOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(GreaterOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct GreaterEqualOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_GreaterEqualOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<GreaterEqualOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(GreaterEqualOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<GreaterEqualOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(GreaterEqualOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct GreaterEqualOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type GreaterEqualOptions_NativeTableType = root::tflite::GreaterEqualOptionsT;

            #[test]
            fn bindgen_test_layout_GreaterEqualOptions() {
                assert_eq!(
                    ::std::mem::size_of::<GreaterEqualOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(GreaterEqualOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<GreaterEqualOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(GreaterEqualOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct LessOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_LessOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<LessOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(LessOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<LessOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(LessOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct LessOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type LessOptions_NativeTableType = root::tflite::LessOptionsT;

            #[test]
            fn bindgen_test_layout_LessOptions() {
                assert_eq!(
                    ::std::mem::size_of::<LessOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(LessOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<LessOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(LessOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct LessEqualOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_LessEqualOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<LessEqualOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(LessEqualOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<LessEqualOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(LessEqualOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct LessEqualOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type LessEqualOptions_NativeTableType = root::tflite::LessEqualOptionsT;

            #[test]
            fn bindgen_test_layout_LessEqualOptions() {
                assert_eq!(
                    ::std::mem::size_of::<LessEqualOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(LessEqualOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<LessEqualOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(LessEqualOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct NegOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_NegOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<NegOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(NegOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<NegOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(NegOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct NegOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type NegOptions_NativeTableType = root::tflite::NegOptionsT;

            #[test]
            fn bindgen_test_layout_NegOptions() {
                assert_eq!(
                    ::std::mem::size_of::<NegOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(NegOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<NegOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(NegOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SelectOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_SelectOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<SelectOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(SelectOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<SelectOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SelectOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SelectOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type SelectOptions_NativeTableType = root::tflite::SelectOptionsT;

            #[test]
            fn bindgen_test_layout_SelectOptions() {
                assert_eq!(
                    ::std::mem::size_of::<SelectOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(SelectOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<SelectOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SelectOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SliceOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_SliceOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<SliceOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(SliceOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<SliceOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SliceOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SliceOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type SliceOptions_NativeTableType = root::tflite::SliceOptionsT;

            #[test]
            fn bindgen_test_layout_SliceOptions() {
                assert_eq!(
                    ::std::mem::size_of::<SliceOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(SliceOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<SliceOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SliceOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct TransposeConvOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub padding: root::tflite::Padding,
                pub stride_w: i32,
                pub stride_h: i32,
            }

            #[test]
            fn bindgen_test_layout_TransposeConvOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<TransposeConvOptionsT>(),
                    12usize,
                    concat!("Size of: ", stringify!(TransposeConvOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<TransposeConvOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(TransposeConvOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<TransposeConvOptionsT>())).padding as *const _
                            as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(TransposeConvOptionsT),
                        "::",
                        stringify!(padding)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<TransposeConvOptionsT>())).stride_w as *const _
                            as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(TransposeConvOptionsT),
                        "::",
                        stringify!(stride_w)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<TransposeConvOptionsT>())).stride_h as *const _
                            as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(TransposeConvOptionsT),
                        "::",
                        stringify!(stride_h)
                    )
                );
            }

            impl Default for TransposeConvOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct TransposeConvOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type TransposeConvOptions_NativeTableType = root::tflite::TransposeConvOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum TransposeConvOptions_FlatBuffersVTableOffset {
                VT_PADDING = 4,
                VT_STRIDE_W = 6,
                VT_STRIDE_H = 8,
            }

            #[test]
            fn bindgen_test_layout_TransposeConvOptions() {
                assert_eq!(
                    ::std::mem::size_of::<TransposeConvOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(TransposeConvOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<TransposeConvOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(TransposeConvOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ExpandDimsOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_ExpandDimsOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<ExpandDimsOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(ExpandDimsOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<ExpandDimsOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ExpandDimsOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ExpandDimsOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type ExpandDimsOptions_NativeTableType = root::tflite::ExpandDimsOptionsT;

            #[test]
            fn bindgen_test_layout_ExpandDimsOptions() {
                assert_eq!(
                    ::std::mem::size_of::<ExpandDimsOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(ExpandDimsOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<ExpandDimsOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ExpandDimsOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SparseToDenseOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub validate_indices: bool,
            }

            #[test]
            fn bindgen_test_layout_SparseToDenseOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<SparseToDenseOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(SparseToDenseOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<SparseToDenseOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SparseToDenseOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SparseToDenseOptionsT>())).validate_indices
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SparseToDenseOptionsT),
                        "::",
                        stringify!(validate_indices)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SparseToDenseOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type SparseToDenseOptions_NativeTableType = root::tflite::SparseToDenseOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum SparseToDenseOptions_FlatBuffersVTableOffset {
                VT_VALIDATE_INDICES = 4,
            }

            #[test]
            fn bindgen_test_layout_SparseToDenseOptions() {
                assert_eq!(
                    ::std::mem::size_of::<SparseToDenseOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(SparseToDenseOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<SparseToDenseOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SparseToDenseOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct EqualOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_EqualOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<EqualOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(EqualOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<EqualOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(EqualOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct EqualOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type EqualOptions_NativeTableType = root::tflite::EqualOptionsT;

            #[test]
            fn bindgen_test_layout_EqualOptions() {
                assert_eq!(
                    ::std::mem::size_of::<EqualOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(EqualOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<EqualOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(EqualOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct NotEqualOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_NotEqualOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<NotEqualOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(NotEqualOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<NotEqualOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(NotEqualOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct NotEqualOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type NotEqualOptions_NativeTableType = root::tflite::NotEqualOptionsT;

            #[test]
            fn bindgen_test_layout_NotEqualOptions() {
                assert_eq!(
                    ::std::mem::size_of::<NotEqualOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(NotEqualOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<NotEqualOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(NotEqualOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct ShapeOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub out_type: root::tflite::TensorType,
            }

            #[test]
            fn bindgen_test_layout_ShapeOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<ShapeOptionsT>(),
                    4usize,
                    concat!("Size of: ", stringify!(ShapeOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<ShapeOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(ShapeOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<ShapeOptionsT>())).out_type as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ShapeOptionsT),
                        "::",
                        stringify!(out_type)
                    )
                );
            }

            impl Default for ShapeOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ShapeOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type ShapeOptions_NativeTableType = root::tflite::ShapeOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum ShapeOptions_FlatBuffersVTableOffset {
                VT_OUT_TYPE = 4,
            }

            #[test]
            fn bindgen_test_layout_ShapeOptions() {
                assert_eq!(
                    ::std::mem::size_of::<ShapeOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(ShapeOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<ShapeOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ShapeOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct RankOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_RankOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<RankOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(RankOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<RankOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(RankOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct RankOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type RankOptions_NativeTableType = root::tflite::RankOptionsT;

            #[test]
            fn bindgen_test_layout_RankOptions() {
                assert_eq!(
                    ::std::mem::size_of::<RankOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(RankOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<RankOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(RankOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct PowOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_PowOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<PowOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(PowOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<PowOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(PowOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct PowOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type PowOptions_NativeTableType = root::tflite::PowOptionsT;

            #[test]
            fn bindgen_test_layout_PowOptions() {
                assert_eq!(
                    ::std::mem::size_of::<PowOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(PowOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<PowOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(PowOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq)]
            pub struct FakeQuantOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub min: f32,
                pub max: f32,
                pub num_bits: i32,
                pub narrow_range: bool,
            }

            #[test]
            fn bindgen_test_layout_FakeQuantOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<FakeQuantOptionsT>(),
                    16usize,
                    concat!("Size of: ", stringify!(FakeQuantOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<FakeQuantOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(FakeQuantOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<FakeQuantOptionsT>())).min as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(FakeQuantOptionsT),
                        "::",
                        stringify!(min)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<FakeQuantOptionsT>())).max as *const _ as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(FakeQuantOptionsT),
                        "::",
                        stringify!(max)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<FakeQuantOptionsT>())).num_bits as *const _ as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(FakeQuantOptionsT),
                        "::",
                        stringify!(num_bits)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<FakeQuantOptionsT>())).narrow_range as *const _
                            as usize
                    },
                    12usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(FakeQuantOptionsT),
                        "::",
                        stringify!(narrow_range)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct FakeQuantOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type FakeQuantOptions_NativeTableType = root::tflite::FakeQuantOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum FakeQuantOptions_FlatBuffersVTableOffset {
                VT_MIN = 4,
                VT_MAX = 6,
                VT_NUM_BITS = 8,
                VT_NARROW_RANGE = 10,
            }

            #[test]
            fn bindgen_test_layout_FakeQuantOptions() {
                assert_eq!(
                    ::std::mem::size_of::<FakeQuantOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(FakeQuantOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<FakeQuantOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(FakeQuantOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct PackOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub values_count: i32,
                pub axis: i32,
            }

            #[test]
            fn bindgen_test_layout_PackOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<PackOptionsT>(),
                    8usize,
                    concat!("Size of: ", stringify!(PackOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<PackOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(PackOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<PackOptionsT>())).values_count as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(PackOptionsT),
                        "::",
                        stringify!(values_count)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<PackOptionsT>())).axis as *const _ as usize },
                    4usize,
                    concat!("Offset of field: ", stringify!(PackOptionsT), "::", stringify!(axis))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct PackOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type PackOptions_NativeTableType = root::tflite::PackOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum PackOptions_FlatBuffersVTableOffset {
                VT_VALUES_COUNT = 4,
                VT_AXIS = 6,
            }

            #[test]
            fn bindgen_test_layout_PackOptions() {
                assert_eq!(
                    ::std::mem::size_of::<PackOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(PackOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<PackOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(PackOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct LogicalOrOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_LogicalOrOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<LogicalOrOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(LogicalOrOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<LogicalOrOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(LogicalOrOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct LogicalOrOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type LogicalOrOptions_NativeTableType = root::tflite::LogicalOrOptionsT;

            #[test]
            fn bindgen_test_layout_LogicalOrOptions() {
                assert_eq!(
                    ::std::mem::size_of::<LogicalOrOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(LogicalOrOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<LogicalOrOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(LogicalOrOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct OneHotOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub axis: i32,
            }

            #[test]
            fn bindgen_test_layout_OneHotOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<OneHotOptionsT>(),
                    4usize,
                    concat!("Size of: ", stringify!(OneHotOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<OneHotOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(OneHotOptionsT))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<OneHotOptionsT>())).axis as *const _ as usize },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(OneHotOptionsT),
                        "::",
                        stringify!(axis)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct OneHotOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type OneHotOptions_NativeTableType = root::tflite::OneHotOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum OneHotOptions_FlatBuffersVTableOffset {
                VT_AXIS = 4,
            }

            #[test]
            fn bindgen_test_layout_OneHotOptions() {
                assert_eq!(
                    ::std::mem::size_of::<OneHotOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(OneHotOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<OneHotOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(OneHotOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct AbsOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_AbsOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<AbsOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(AbsOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<AbsOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(AbsOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct AbsOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type AbsOptions_NativeTableType = root::tflite::AbsOptionsT;

            #[test]
            fn bindgen_test_layout_AbsOptions() {
                assert_eq!(
                    ::std::mem::size_of::<AbsOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(AbsOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<AbsOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(AbsOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct HardSwishOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_HardSwishOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<HardSwishOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(HardSwishOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<HardSwishOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(HardSwishOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct HardSwishOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type HardSwishOptions_NativeTableType = root::tflite::HardSwishOptionsT;

            #[test]
            fn bindgen_test_layout_HardSwishOptions() {
                assert_eq!(
                    ::std::mem::size_of::<HardSwishOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(HardSwishOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<HardSwishOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(HardSwishOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct LogicalAndOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_LogicalAndOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<LogicalAndOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(LogicalAndOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<LogicalAndOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(LogicalAndOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct LogicalAndOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type LogicalAndOptions_NativeTableType = root::tflite::LogicalAndOptionsT;

            #[test]
            fn bindgen_test_layout_LogicalAndOptions() {
                assert_eq!(
                    ::std::mem::size_of::<LogicalAndOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(LogicalAndOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<LogicalAndOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(LogicalAndOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct LogicalNotOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_LogicalNotOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<LogicalNotOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(LogicalNotOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<LogicalNotOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(LogicalNotOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct LogicalNotOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type LogicalNotOptions_NativeTableType = root::tflite::LogicalNotOptionsT;

            #[test]
            fn bindgen_test_layout_LogicalNotOptions() {
                assert_eq!(
                    ::std::mem::size_of::<LogicalNotOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(LogicalNotOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<LogicalNotOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(LogicalNotOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct UnpackOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub num: i32,
                pub axis: i32,
            }

            #[test]
            fn bindgen_test_layout_UnpackOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<UnpackOptionsT>(),
                    8usize,
                    concat!("Size of: ", stringify!(UnpackOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<UnpackOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(UnpackOptionsT))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<UnpackOptionsT>())).num as *const _ as usize },
                    0usize,
                    concat!("Offset of field: ", stringify!(UnpackOptionsT), "::", stringify!(num))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<UnpackOptionsT>())).axis as *const _ as usize },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(UnpackOptionsT),
                        "::",
                        stringify!(axis)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct UnpackOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type UnpackOptions_NativeTableType = root::tflite::UnpackOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum UnpackOptions_FlatBuffersVTableOffset {
                VT_NUM = 4,
                VT_AXIS = 6,
            }

            #[test]
            fn bindgen_test_layout_UnpackOptions() {
                assert_eq!(
                    ::std::mem::size_of::<UnpackOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(UnpackOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<UnpackOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(UnpackOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct FloorDivOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_FloorDivOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<FloorDivOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(FloorDivOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<FloorDivOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(FloorDivOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct FloorDivOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type FloorDivOptions_NativeTableType = root::tflite::FloorDivOptionsT;

            #[test]
            fn bindgen_test_layout_FloorDivOptions() {
                assert_eq!(
                    ::std::mem::size_of::<FloorDivOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(FloorDivOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<FloorDivOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(FloorDivOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SquareOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_SquareOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<SquareOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(SquareOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<SquareOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SquareOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SquareOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type SquareOptions_NativeTableType = root::tflite::SquareOptionsT;

            #[test]
            fn bindgen_test_layout_SquareOptions() {
                assert_eq!(
                    ::std::mem::size_of::<SquareOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(SquareOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<SquareOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SquareOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ZerosLikeOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_ZerosLikeOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<ZerosLikeOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(ZerosLikeOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<ZerosLikeOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ZerosLikeOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ZerosLikeOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type ZerosLikeOptions_NativeTableType = root::tflite::ZerosLikeOptionsT;

            #[test]
            fn bindgen_test_layout_ZerosLikeOptions() {
                assert_eq!(
                    ::std::mem::size_of::<ZerosLikeOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(ZerosLikeOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<ZerosLikeOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ZerosLikeOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct FillOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_FillOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<FillOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(FillOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<FillOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(FillOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct FillOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type FillOptions_NativeTableType = root::tflite::FillOptionsT;

            #[test]
            fn bindgen_test_layout_FillOptions() {
                assert_eq!(
                    ::std::mem::size_of::<FillOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(FillOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<FillOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(FillOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct FloorModOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_FloorModOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<FloorModOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(FloorModOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<FloorModOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(FloorModOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct FloorModOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type FloorModOptions_NativeTableType = root::tflite::FloorModOptionsT;

            #[test]
            fn bindgen_test_layout_FloorModOptions() {
                assert_eq!(
                    ::std::mem::size_of::<FloorModOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(FloorModOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<FloorModOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(FloorModOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct RangeOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_RangeOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<RangeOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(RangeOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<RangeOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(RangeOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct RangeOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type RangeOptions_NativeTableType = root::tflite::RangeOptionsT;

            #[test]
            fn bindgen_test_layout_RangeOptions() {
                assert_eq!(
                    ::std::mem::size_of::<RangeOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(RangeOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<RangeOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(RangeOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq)]
            pub struct LeakyReluOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub alpha: f32,
            }

            #[test]
            fn bindgen_test_layout_LeakyReluOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<LeakyReluOptionsT>(),
                    4usize,
                    concat!("Size of: ", stringify!(LeakyReluOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<LeakyReluOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(LeakyReluOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<LeakyReluOptionsT>())).alpha as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(LeakyReluOptionsT),
                        "::",
                        stringify!(alpha)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct LeakyReluOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type LeakyReluOptions_NativeTableType = root::tflite::LeakyReluOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum LeakyReluOptions_FlatBuffersVTableOffset {
                VT_ALPHA = 4,
            }

            #[test]
            fn bindgen_test_layout_LeakyReluOptions() {
                assert_eq!(
                    ::std::mem::size_of::<LeakyReluOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(LeakyReluOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<LeakyReluOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(LeakyReluOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SquaredDifferenceOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_SquaredDifferenceOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<SquaredDifferenceOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(SquaredDifferenceOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<SquaredDifferenceOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SquaredDifferenceOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SquaredDifferenceOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type SquaredDifferenceOptions_NativeTableType =
                root::tflite::SquaredDifferenceOptionsT;

            #[test]
            fn bindgen_test_layout_SquaredDifferenceOptions() {
                assert_eq!(
                    ::std::mem::size_of::<SquaredDifferenceOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(SquaredDifferenceOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<SquaredDifferenceOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SquaredDifferenceOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct MirrorPadOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub mode: root::tflite::MirrorPadMode,
            }

            #[test]
            fn bindgen_test_layout_MirrorPadOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<MirrorPadOptionsT>(),
                    4usize,
                    concat!("Size of: ", stringify!(MirrorPadOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<MirrorPadOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(MirrorPadOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<MirrorPadOptionsT>())).mode as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(MirrorPadOptionsT),
                        "::",
                        stringify!(mode)
                    )
                );
            }

            impl Default for MirrorPadOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct MirrorPadOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type MirrorPadOptions_NativeTableType = root::tflite::MirrorPadOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum MirrorPadOptions_FlatBuffersVTableOffset {
                VT_MODE = 4,
            }

            #[test]
            fn bindgen_test_layout_MirrorPadOptions() {
                assert_eq!(
                    ::std::mem::size_of::<MirrorPadOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(MirrorPadOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<MirrorPadOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(MirrorPadOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct UniqueOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub idx_out_type: root::tflite::TensorType,
            }

            #[test]
            fn bindgen_test_layout_UniqueOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<UniqueOptionsT>(),
                    4usize,
                    concat!("Size of: ", stringify!(UniqueOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<UniqueOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(UniqueOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<UniqueOptionsT>())).idx_out_type as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(UniqueOptionsT),
                        "::",
                        stringify!(idx_out_type)
                    )
                );
            }

            impl Default for UniqueOptionsT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct UniqueOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type UniqueOptions_NativeTableType = root::tflite::UniqueOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum UniqueOptions_FlatBuffersVTableOffset {
                VT_IDX_OUT_TYPE = 4,
            }

            #[test]
            fn bindgen_test_layout_UniqueOptions() {
                assert_eq!(
                    ::std::mem::size_of::<UniqueOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(UniqueOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<UniqueOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(UniqueOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ReverseV2OptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_ReverseV2OptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<ReverseV2OptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(ReverseV2OptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<ReverseV2OptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ReverseV2OptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ReverseV2Options {
                pub _base: root::flatbuffers::Table,
            }

            pub type ReverseV2Options_NativeTableType = root::tflite::ReverseV2OptionsT;

            #[test]
            fn bindgen_test_layout_ReverseV2Options() {
                assert_eq!(
                    ::std::mem::size_of::<ReverseV2Options>(),
                    1usize,
                    concat!("Size of: ", stringify!(ReverseV2Options))
                );
                assert_eq!(
                    ::std::mem::align_of::<ReverseV2Options>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ReverseV2Options))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct AddNOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_AddNOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<AddNOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(AddNOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<AddNOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(AddNOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct AddNOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type AddNOptions_NativeTableType = root::tflite::AddNOptionsT;

            #[test]
            fn bindgen_test_layout_AddNOptions() {
                assert_eq!(
                    ::std::mem::size_of::<AddNOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(AddNOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<AddNOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(AddNOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct GatherNdOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_GatherNdOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<GatherNdOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(GatherNdOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<GatherNdOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(GatherNdOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct GatherNdOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type GatherNdOptions_NativeTableType = root::tflite::GatherNdOptionsT;

            #[test]
            fn bindgen_test_layout_GatherNdOptions() {
                assert_eq!(
                    ::std::mem::size_of::<GatherNdOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(GatherNdOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<GatherNdOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(GatherNdOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct WhereOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_WhereOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<WhereOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(WhereOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<WhereOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(WhereOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct WhereOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type WhereOptions_NativeTableType = root::tflite::WhereOptionsT;

            #[test]
            fn bindgen_test_layout_WhereOptions() {
                assert_eq!(
                    ::std::mem::size_of::<WhereOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(WhereOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<WhereOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(WhereOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ReverseSequenceOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub seq_dim: i32,
                pub batch_dim: i32,
            }

            #[test]
            fn bindgen_test_layout_ReverseSequenceOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<ReverseSequenceOptionsT>(),
                    8usize,
                    concat!("Size of: ", stringify!(ReverseSequenceOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<ReverseSequenceOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(ReverseSequenceOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<ReverseSequenceOptionsT>())).seq_dim as *const _
                            as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ReverseSequenceOptionsT),
                        "::",
                        stringify!(seq_dim)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<ReverseSequenceOptionsT>())).batch_dim as *const _
                            as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ReverseSequenceOptionsT),
                        "::",
                        stringify!(batch_dim)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ReverseSequenceOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type ReverseSequenceOptions_NativeTableType = root::tflite::ReverseSequenceOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum ReverseSequenceOptions_FlatBuffersVTableOffset {
                VT_SEQ_DIM = 4,
                VT_BATCH_DIM = 6,
            }

            #[test]
            fn bindgen_test_layout_ReverseSequenceOptions() {
                assert_eq!(
                    ::std::mem::size_of::<ReverseSequenceOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(ReverseSequenceOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<ReverseSequenceOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ReverseSequenceOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct MatrixDiagOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_MatrixDiagOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<MatrixDiagOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(MatrixDiagOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<MatrixDiagOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(MatrixDiagOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct MatrixDiagOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type MatrixDiagOptions_NativeTableType = root::tflite::MatrixDiagOptionsT;

            #[test]
            fn bindgen_test_layout_MatrixDiagOptions() {
                assert_eq!(
                    ::std::mem::size_of::<MatrixDiagOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(MatrixDiagOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<MatrixDiagOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(MatrixDiagOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct QuantizeOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_QuantizeOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<QuantizeOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(QuantizeOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<QuantizeOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(QuantizeOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct QuantizeOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type QuantizeOptions_NativeTableType = root::tflite::QuantizeOptionsT;

            #[test]
            fn bindgen_test_layout_QuantizeOptions() {
                assert_eq!(
                    ::std::mem::size_of::<QuantizeOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(QuantizeOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<QuantizeOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(QuantizeOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct MatrixSetDiagOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_MatrixSetDiagOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<MatrixSetDiagOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(MatrixSetDiagOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<MatrixSetDiagOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(MatrixSetDiagOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct MatrixSetDiagOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type MatrixSetDiagOptions_NativeTableType = root::tflite::MatrixSetDiagOptionsT;

            #[test]
            fn bindgen_test_layout_MatrixSetDiagOptions() {
                assert_eq!(
                    ::std::mem::size_of::<MatrixSetDiagOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(MatrixSetDiagOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<MatrixSetDiagOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(MatrixSetDiagOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct IfOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub then_subgraph_index: i32,
                pub else_subgraph_index: i32,
            }

            #[test]
            fn bindgen_test_layout_IfOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<IfOptionsT>(),
                    8usize,
                    concat!("Size of: ", stringify!(IfOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<IfOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(IfOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<IfOptionsT>())).then_subgraph_index as *const _
                            as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(IfOptionsT),
                        "::",
                        stringify!(then_subgraph_index)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<IfOptionsT>())).else_subgraph_index as *const _
                            as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(IfOptionsT),
                        "::",
                        stringify!(else_subgraph_index)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct IfOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type IfOptions_NativeTableType = root::tflite::IfOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum IfOptions_FlatBuffersVTableOffset {
                VT_THEN_SUBGRAPH_INDEX = 4,
                VT_ELSE_SUBGRAPH_INDEX = 6,
            }

            #[test]
            fn bindgen_test_layout_IfOptions() {
                assert_eq!(
                    ::std::mem::size_of::<IfOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(IfOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<IfOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(IfOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct WhileOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub cond_subgraph_index: i32,
                pub body_subgraph_index: i32,
            }

            #[test]
            fn bindgen_test_layout_WhileOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<WhileOptionsT>(),
                    8usize,
                    concat!("Size of: ", stringify!(WhileOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<WhileOptionsT>(),
                    4usize,
                    concat!("Alignment of ", stringify!(WhileOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<WhileOptionsT>())).cond_subgraph_index as *const _
                            as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(WhileOptionsT),
                        "::",
                        stringify!(cond_subgraph_index)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<WhileOptionsT>())).body_subgraph_index as *const _
                            as usize
                    },
                    4usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(WhileOptionsT),
                        "::",
                        stringify!(body_subgraph_index)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct WhileOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type WhileOptions_NativeTableType = root::tflite::WhileOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum WhileOptions_FlatBuffersVTableOffset {
                VT_COND_SUBGRAPH_INDEX = 4,
                VT_BODY_SUBGRAPH_INDEX = 6,
            }

            #[test]
            fn bindgen_test_layout_WhileOptions() {
                assert_eq!(
                    ::std::mem::size_of::<WhileOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(WhileOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<WhileOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(WhileOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct NonMaxSuppressionV4OptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_NonMaxSuppressionV4OptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<NonMaxSuppressionV4OptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(NonMaxSuppressionV4OptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<NonMaxSuppressionV4OptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(NonMaxSuppressionV4OptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct NonMaxSuppressionV4Options {
                pub _base: root::flatbuffers::Table,
            }

            pub type NonMaxSuppressionV4Options_NativeTableType =
                root::tflite::NonMaxSuppressionV4OptionsT;

            #[test]
            fn bindgen_test_layout_NonMaxSuppressionV4Options() {
                assert_eq!(
                    ::std::mem::size_of::<NonMaxSuppressionV4Options>(),
                    1usize,
                    concat!("Size of: ", stringify!(NonMaxSuppressionV4Options))
                );
                assert_eq!(
                    ::std::mem::align_of::<NonMaxSuppressionV4Options>(),
                    1usize,
                    concat!("Alignment of ", stringify!(NonMaxSuppressionV4Options))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct NonMaxSuppressionV5OptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_NonMaxSuppressionV5OptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<NonMaxSuppressionV5OptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(NonMaxSuppressionV5OptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<NonMaxSuppressionV5OptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(NonMaxSuppressionV5OptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct NonMaxSuppressionV5Options {
                pub _base: root::flatbuffers::Table,
            }

            pub type NonMaxSuppressionV5Options_NativeTableType =
                root::tflite::NonMaxSuppressionV5OptionsT;

            #[test]
            fn bindgen_test_layout_NonMaxSuppressionV5Options() {
                assert_eq!(
                    ::std::mem::size_of::<NonMaxSuppressionV5Options>(),
                    1usize,
                    concat!("Size of: ", stringify!(NonMaxSuppressionV5Options))
                );
                assert_eq!(
                    ::std::mem::align_of::<NonMaxSuppressionV5Options>(),
                    1usize,
                    concat!("Alignment of ", stringify!(NonMaxSuppressionV5Options))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ScatterNdOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_ScatterNdOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<ScatterNdOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(ScatterNdOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<ScatterNdOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ScatterNdOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct ScatterNdOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type ScatterNdOptions_NativeTableType = root::tflite::ScatterNdOptionsT;

            #[test]
            fn bindgen_test_layout_ScatterNdOptions() {
                assert_eq!(
                    ::std::mem::size_of::<ScatterNdOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(ScatterNdOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<ScatterNdOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(ScatterNdOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SelectV2OptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_SelectV2OptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<SelectV2OptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(SelectV2OptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<SelectV2OptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SelectV2OptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SelectV2Options {
                pub _base: root::flatbuffers::Table,
            }

            pub type SelectV2Options_NativeTableType = root::tflite::SelectV2OptionsT;

            #[test]
            fn bindgen_test_layout_SelectV2Options() {
                assert_eq!(
                    ::std::mem::size_of::<SelectV2Options>(),
                    1usize,
                    concat!("Size of: ", stringify!(SelectV2Options))
                );
                assert_eq!(
                    ::std::mem::align_of::<SelectV2Options>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SelectV2Options))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct DensifyOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_DensifyOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<DensifyOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(DensifyOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<DensifyOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(DensifyOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct DensifyOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type DensifyOptions_NativeTableType = root::tflite::DensifyOptionsT;

            #[test]
            fn bindgen_test_layout_DensifyOptions() {
                assert_eq!(
                    ::std::mem::size_of::<DensifyOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(DensifyOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<DensifyOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(DensifyOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SegmentSumOptionsT {
                pub _base: u8,
            }

            #[test]
            fn bindgen_test_layout_SegmentSumOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<SegmentSumOptionsT>(),
                    1usize,
                    concat!("Size of: ", stringify!(SegmentSumOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<SegmentSumOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SegmentSumOptionsT))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SegmentSumOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type SegmentSumOptions_NativeTableType = root::tflite::SegmentSumOptionsT;

            #[test]
            fn bindgen_test_layout_SegmentSumOptions() {
                assert_eq!(
                    ::std::mem::size_of::<SegmentSumOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(SegmentSumOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<SegmentSumOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SegmentSumOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct BatchMatMulOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub adj_x: bool,
                pub adj_y: bool,
            }

            #[test]
            fn bindgen_test_layout_BatchMatMulOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<BatchMatMulOptionsT>(),
                    2usize,
                    concat!("Size of: ", stringify!(BatchMatMulOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<BatchMatMulOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(BatchMatMulOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<BatchMatMulOptionsT>())).adj_x as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BatchMatMulOptionsT),
                        "::",
                        stringify!(adj_x)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<BatchMatMulOptionsT>())).adj_y as *const _ as usize
                    },
                    1usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(BatchMatMulOptionsT),
                        "::",
                        stringify!(adj_y)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct BatchMatMulOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type BatchMatMulOptions_NativeTableType = root::tflite::BatchMatMulOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum BatchMatMulOptions_FlatBuffersVTableOffset {
                VT_ADJ_X = 4,
                VT_ADJ_Y = 6,
            }

            #[test]
            fn bindgen_test_layout_BatchMatMulOptions() {
                assert_eq!(
                    ::std::mem::size_of::<BatchMatMulOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(BatchMatMulOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<BatchMatMulOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(BatchMatMulOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct CumsumOptionsT {
                pub _base: root::flatbuffers::NativeTable,
                pub exclusive: bool,
                pub reverse: bool,
            }

            #[test]
            fn bindgen_test_layout_CumsumOptionsT() {
                assert_eq!(
                    ::std::mem::size_of::<CumsumOptionsT>(),
                    2usize,
                    concat!("Size of: ", stringify!(CumsumOptionsT))
                );
                assert_eq!(
                    ::std::mem::align_of::<CumsumOptionsT>(),
                    1usize,
                    concat!("Alignment of ", stringify!(CumsumOptionsT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<CumsumOptionsT>())).exclusive as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CumsumOptionsT),
                        "::",
                        stringify!(exclusive)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<CumsumOptionsT>())).reverse as *const _ as usize
                    },
                    1usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(CumsumOptionsT),
                        "::",
                        stringify!(reverse)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct CumsumOptions {
                pub _base: root::flatbuffers::Table,
            }

            pub type CumsumOptions_NativeTableType = root::tflite::CumsumOptionsT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum CumsumOptions_FlatBuffersVTableOffset {
                VT_EXCLUSIVE = 4,
                VT_REVERSE = 6,
            }

            #[test]
            fn bindgen_test_layout_CumsumOptions() {
                assert_eq!(
                    ::std::mem::size_of::<CumsumOptions>(),
                    1usize,
                    concat!("Size of: ", stringify!(CumsumOptions))
                );
                assert_eq!(
                    ::std::mem::align_of::<CumsumOptions>(),
                    1usize,
                    concat!("Alignment of ", stringify!(CumsumOptions))
                );
            }

            #[repr(C)]
            #[derive(Debug, Copy, Clone, PartialEq, Eq)]
            pub struct OperatorCodeT {
                pub _base: root::flatbuffers::NativeTable,
                pub deprecated_builtin_code: i8,
                pub custom_code: root::std::string,
                pub version: i32,
                pub builtin_code: root::tflite::BuiltinOperator,
            }

            #[test]
            fn bindgen_test_layout_OperatorCodeT() {
                assert_eq!(
                    ::std::mem::size_of::<OperatorCodeT>(),
                    48usize,
                    concat!("Size of: ", stringify!(OperatorCodeT))
                );
                assert_eq!(
                    ::std::mem::align_of::<OperatorCodeT>(),
                    8usize,
                    concat!("Alignment of ", stringify!(OperatorCodeT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<OperatorCodeT>())).deprecated_builtin_code
                            as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(OperatorCodeT),
                        "::",
                        stringify!(deprecated_builtin_code)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<OperatorCodeT>())).custom_code as *const _ as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(OperatorCodeT),
                        "::",
                        stringify!(custom_code)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<OperatorCodeT>())).version as *const _ as usize
                    },
                    40usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(OperatorCodeT),
                        "::",
                        stringify!(version)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<OperatorCodeT>())).builtin_code as *const _ as usize
                    },
                    44usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(OperatorCodeT),
                        "::",
                        stringify!(builtin_code)
                    )
                );
            }

            impl Default for OperatorCodeT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct OperatorCode {
                pub _base: root::flatbuffers::Table,
            }

            pub type OperatorCode_NativeTableType = root::tflite::OperatorCodeT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum OperatorCode_FlatBuffersVTableOffset {
                VT_DEPRECATED_BUILTIN_CODE = 4,
                VT_CUSTOM_CODE = 6,
                VT_VERSION = 8,
                VT_BUILTIN_CODE = 10,
            }

            #[test]
            fn bindgen_test_layout_OperatorCode() {
                assert_eq!(
                    ::std::mem::size_of::<OperatorCode>(),
                    1usize,
                    concat!("Size of: ", stringify!(OperatorCode))
                );
                assert_eq!(
                    ::std::mem::align_of::<OperatorCode>(),
                    1usize,
                    concat!("Alignment of ", stringify!(OperatorCode))
                );
            }

            #[repr(C)]
            #[derive(Debug, PartialEq, Eq)]
            pub struct OperatorT {
                pub _base: root::flatbuffers::NativeTable,
                pub opcode_index: u32,
                pub inputs: root::std::vector,
                pub outputs: root::std::vector,
                pub builtin_options: root::tflite::BuiltinOptionsUnion,
                pub custom_options: root::std::vector,
                pub custom_options_format: root::tflite::CustomOptionsFormat,
                pub mutating_variable_inputs: [u64; 5usize],
                pub intermediates: root::std::vector,
            }

            #[test]
            fn bindgen_test_layout_OperatorT() {
                assert_eq!(
                    ::std::mem::size_of::<OperatorT>(),
                    168usize,
                    concat!("Size of: ", stringify!(OperatorT))
                );
                assert_eq!(
                    ::std::mem::align_of::<OperatorT>(),
                    8usize,
                    concat!("Alignment of ", stringify!(OperatorT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<OperatorT>())).opcode_index as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(OperatorT),
                        "::",
                        stringify!(opcode_index)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<OperatorT>())).inputs as *const _ as usize },
                    8usize,
                    concat!("Offset of field: ", stringify!(OperatorT), "::", stringify!(inputs))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<OperatorT>())).outputs as *const _ as usize },
                    32usize,
                    concat!("Offset of field: ", stringify!(OperatorT), "::", stringify!(outputs))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<OperatorT>())).builtin_options as *const _ as usize
                    },
                    56usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(OperatorT),
                        "::",
                        stringify!(builtin_options)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<OperatorT>())).custom_options as *const _ as usize
                    },
                    72usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(OperatorT),
                        "::",
                        stringify!(custom_options)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<OperatorT>())).custom_options_format as *const _
                            as usize
                    },
                    96usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(OperatorT),
                        "::",
                        stringify!(custom_options_format)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<OperatorT>())).mutating_variable_inputs as *const _
                            as usize
                    },
                    104usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(OperatorT),
                        "::",
                        stringify!(mutating_variable_inputs)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<OperatorT>())).intermediates as *const _ as usize
                    },
                    144usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(OperatorT),
                        "::",
                        stringify!(intermediates)
                    )
                );
            }

            impl Default for OperatorT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct Operator {
                pub _base: root::flatbuffers::Table,
            }

            pub type Operator_NativeTableType = root::tflite::OperatorT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum Operator_FlatBuffersVTableOffset {
                VT_OPCODE_INDEX = 4,
                VT_INPUTS = 6,
                VT_OUTPUTS = 8,
                VT_BUILTIN_OPTIONS_TYPE = 10,
                VT_BUILTIN_OPTIONS = 12,
                VT_CUSTOM_OPTIONS = 14,
                VT_CUSTOM_OPTIONS_FORMAT = 16,
                VT_MUTATING_VARIABLE_INPUTS = 18,
                VT_INTERMEDIATES = 20,
            }

            #[test]
            fn bindgen_test_layout_Operator() {
                assert_eq!(
                    ::std::mem::size_of::<Operator>(),
                    1usize,
                    concat!("Size of: ", stringify!(Operator))
                );
                assert_eq!(
                    ::std::mem::align_of::<Operator>(),
                    1usize,
                    concat!("Alignment of ", stringify!(Operator))
                );
            }

            #[repr(C)]
            #[derive(Debug, PartialEq)]
            pub struct SubGraphT {
                pub _base: root::flatbuffers::NativeTable,
                pub tensors: root::std::vector,
                pub inputs: root::std::vector,
                pub outputs: root::std::vector,
                pub operators: root::std::vector,
                pub name: root::std::string,
            }

            #[test]
            fn bindgen_test_layout_SubGraphT() {
                assert_eq!(
                    ::std::mem::size_of::<SubGraphT>(),
                    128usize,
                    concat!("Size of: ", stringify!(SubGraphT))
                );
                assert_eq!(
                    ::std::mem::align_of::<SubGraphT>(),
                    8usize,
                    concat!("Alignment of ", stringify!(SubGraphT))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<SubGraphT>())).tensors as *const _ as usize },
                    0usize,
                    concat!("Offset of field: ", stringify!(SubGraphT), "::", stringify!(tensors))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<SubGraphT>())).inputs as *const _ as usize },
                    24usize,
                    concat!("Offset of field: ", stringify!(SubGraphT), "::", stringify!(inputs))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<SubGraphT>())).outputs as *const _ as usize },
                    48usize,
                    concat!("Offset of field: ", stringify!(SubGraphT), "::", stringify!(outputs))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<SubGraphT>())).operators as *const _ as usize },
                    72usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SubGraphT),
                        "::",
                        stringify!(operators)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<SubGraphT>())).name as *const _ as usize },
                    96usize,
                    concat!("Offset of field: ", stringify!(SubGraphT), "::", stringify!(name))
                );
            }

            impl Default for SubGraphT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SubGraph {
                pub _base: root::flatbuffers::Table,
            }

            pub type SubGraph_NativeTableType = root::tflite::SubGraphT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum SubGraph_FlatBuffersVTableOffset {
                VT_TENSORS = 4,
                VT_INPUTS = 6,
                VT_OUTPUTS = 8,
                VT_OPERATORS = 10,
                VT_NAME = 12,
            }

            #[test]
            fn bindgen_test_layout_SubGraph() {
                assert_eq!(
                    ::std::mem::size_of::<SubGraph>(),
                    1usize,
                    concat!("Size of: ", stringify!(SubGraph))
                );
                assert_eq!(
                    ::std::mem::align_of::<SubGraph>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SubGraph))
                );
            }

            #[repr(C)]
            #[derive(Debug, PartialEq, Eq)]
            pub struct BufferT {
                pub _base: root::flatbuffers::NativeTable,
                pub data: root::std::vector,
            }

            #[test]
            fn bindgen_test_layout_BufferT() {
                assert_eq!(
                    ::std::mem::size_of::<BufferT>(),
                    24usize,
                    concat!("Size of: ", stringify!(BufferT))
                );
                assert_eq!(
                    ::std::mem::align_of::<BufferT>(),
                    8usize,
                    concat!("Alignment of ", stringify!(BufferT))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<BufferT>())).data as *const _ as usize },
                    0usize,
                    concat!("Offset of field: ", stringify!(BufferT), "::", stringify!(data))
                );
            }

            impl Default for BufferT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct Buffer {
                pub _base: root::flatbuffers::Table,
            }

            pub type Buffer_NativeTableType = root::tflite::BufferT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum Buffer_FlatBuffersVTableOffset {
                VT_DATA = 4,
            }

            #[test]
            fn bindgen_test_layout_Buffer() {
                assert_eq!(
                    ::std::mem::size_of::<Buffer>(),
                    1usize,
                    concat!("Size of: ", stringify!(Buffer))
                );
                assert_eq!(
                    ::std::mem::align_of::<Buffer>(),
                    1usize,
                    concat!("Alignment of ", stringify!(Buffer))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct MetadataT {
                pub _base: root::flatbuffers::NativeTable,
                pub name: root::std::string,
                pub buffer: u32,
            }

            #[test]
            fn bindgen_test_layout_MetadataT() {
                assert_eq!(
                    ::std::mem::size_of::<MetadataT>(),
                    40usize,
                    concat!("Size of: ", stringify!(MetadataT))
                );
                assert_eq!(
                    ::std::mem::align_of::<MetadataT>(),
                    8usize,
                    concat!("Alignment of ", stringify!(MetadataT))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<MetadataT>())).name as *const _ as usize },
                    0usize,
                    concat!("Offset of field: ", stringify!(MetadataT), "::", stringify!(name))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<MetadataT>())).buffer as *const _ as usize },
                    32usize,
                    concat!("Offset of field: ", stringify!(MetadataT), "::", stringify!(buffer))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct Metadata {
                pub _base: root::flatbuffers::Table,
            }

            pub type Metadata_NativeTableType = root::tflite::MetadataT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum Metadata_FlatBuffersVTableOffset {
                VT_NAME = 4,
                VT_BUFFER = 6,
            }

            #[test]
            fn bindgen_test_layout_Metadata() {
                assert_eq!(
                    ::std::mem::size_of::<Metadata>(),
                    1usize,
                    concat!("Size of: ", stringify!(Metadata))
                );
                assert_eq!(
                    ::std::mem::align_of::<Metadata>(),
                    1usize,
                    concat!("Alignment of ", stringify!(Metadata))
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct TensorMapT {
                pub _base: root::flatbuffers::NativeTable,
                pub name: root::std::string,
                pub tensor_index: u32,
            }

            #[test]
            fn bindgen_test_layout_TensorMapT() {
                assert_eq!(
                    ::std::mem::size_of::<TensorMapT>(),
                    40usize,
                    concat!("Size of: ", stringify!(TensorMapT))
                );
                assert_eq!(
                    ::std::mem::align_of::<TensorMapT>(),
                    8usize,
                    concat!("Alignment of ", stringify!(TensorMapT))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<TensorMapT>())).name as *const _ as usize },
                    0usize,
                    concat!("Offset of field: ", stringify!(TensorMapT), "::", stringify!(name))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<TensorMapT>())).tensor_index as *const _ as usize
                    },
                    32usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(TensorMapT),
                        "::",
                        stringify!(tensor_index)
                    )
                );
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct TensorMap {
                pub _base: root::flatbuffers::Table,
            }

            pub type TensorMap_NativeTableType = root::tflite::TensorMapT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum TensorMap_FlatBuffersVTableOffset {
                VT_NAME = 4,
                VT_TENSOR_INDEX = 6,
            }

            #[test]
            fn bindgen_test_layout_TensorMap() {
                assert_eq!(
                    ::std::mem::size_of::<TensorMap>(),
                    1usize,
                    concat!("Size of: ", stringify!(TensorMap))
                );
                assert_eq!(
                    ::std::mem::align_of::<TensorMap>(),
                    1usize,
                    concat!("Alignment of ", stringify!(TensorMap))
                );
            }

            #[repr(C)]
            #[derive(Debug, PartialEq, Eq)]
            pub struct SignatureDefT {
                pub _base: root::flatbuffers::NativeTable,
                pub inputs: root::std::vector,
                pub outputs: root::std::vector,
                pub method_name: root::std::string,
                pub key: root::std::string,
            }

            #[test]
            fn bindgen_test_layout_SignatureDefT() {
                assert_eq!(
                    ::std::mem::size_of::<SignatureDefT>(),
                    112usize,
                    concat!("Size of: ", stringify!(SignatureDefT))
                );
                assert_eq!(
                    ::std::mem::align_of::<SignatureDefT>(),
                    8usize,
                    concat!("Alignment of ", stringify!(SignatureDefT))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SignatureDefT>())).inputs as *const _ as usize
                    },
                    0usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SignatureDefT),
                        "::",
                        stringify!(inputs)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SignatureDefT>())).outputs as *const _ as usize
                    },
                    24usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SignatureDefT),
                        "::",
                        stringify!(outputs)
                    )
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<SignatureDefT>())).method_name as *const _ as usize
                    },
                    48usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(SignatureDefT),
                        "::",
                        stringify!(method_name)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<SignatureDefT>())).key as *const _ as usize },
                    80usize,
                    concat!("Offset of field: ", stringify!(SignatureDefT), "::", stringify!(key))
                );
            }

            impl Default for SignatureDefT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct SignatureDef {
                pub _base: root::flatbuffers::Table,
            }

            pub type SignatureDef_NativeTableType = root::tflite::SignatureDefT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum SignatureDef_FlatBuffersVTableOffset {
                VT_INPUTS = 4,
                VT_OUTPUTS = 6,
                VT_METHOD_NAME = 8,
                VT_KEY = 10,
            }

            #[test]
            fn bindgen_test_layout_SignatureDef() {
                assert_eq!(
                    ::std::mem::size_of::<SignatureDef>(),
                    1usize,
                    concat!("Size of: ", stringify!(SignatureDef))
                );
                assert_eq!(
                    ::std::mem::align_of::<SignatureDef>(),
                    1usize,
                    concat!("Alignment of ", stringify!(SignatureDef))
                );
            }

            #[repr(C)]
            #[derive(Debug, PartialEq)]
            pub struct ModelT {
                pub _base: root::flatbuffers::NativeTable,
                pub version: u32,
                pub operator_codes: root::std::vector,
                pub subgraphs: root::std::vector,
                pub description: root::std::string,
                pub buffers: root::std::vector,
                pub metadata_buffer: root::std::vector,
                pub metadata: root::std::vector,
                pub signature_defs: root::std::vector,
            }

            #[test]
            fn bindgen_test_layout_ModelT() {
                assert_eq!(
                    ::std::mem::size_of::<ModelT>(),
                    184usize,
                    concat!("Size of: ", stringify!(ModelT))
                );
                assert_eq!(
                    ::std::mem::align_of::<ModelT>(),
                    8usize,
                    concat!("Alignment of ", stringify!(ModelT))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<ModelT>())).version as *const _ as usize },
                    0usize,
                    concat!("Offset of field: ", stringify!(ModelT), "::", stringify!(version))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<ModelT>())).operator_codes as *const _ as usize
                    },
                    8usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ModelT),
                        "::",
                        stringify!(operator_codes)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<ModelT>())).subgraphs as *const _ as usize },
                    32usize,
                    concat!("Offset of field: ", stringify!(ModelT), "::", stringify!(subgraphs))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<ModelT>())).description as *const _ as usize },
                    56usize,
                    concat!("Offset of field: ", stringify!(ModelT), "::", stringify!(description))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<ModelT>())).buffers as *const _ as usize },
                    88usize,
                    concat!("Offset of field: ", stringify!(ModelT), "::", stringify!(buffers))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<ModelT>())).metadata_buffer as *const _ as usize
                    },
                    112usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ModelT),
                        "::",
                        stringify!(metadata_buffer)
                    )
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<ModelT>())).metadata as *const _ as usize },
                    136usize,
                    concat!("Offset of field: ", stringify!(ModelT), "::", stringify!(metadata))
                );
                assert_eq!(
                    unsafe {
                        &(*(::std::ptr::null::<ModelT>())).signature_defs as *const _ as usize
                    },
                    160usize,
                    concat!(
                        "Offset of field: ",
                        stringify!(ModelT),
                        "::",
                        stringify!(signature_defs)
                    )
                );
            }

            impl Default for ModelT {
                fn default() -> Self {
                    unsafe { ::std::mem::zeroed() }
                }
            }

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct Model {
                pub _base: root::flatbuffers::Table,
            }

            pub type Model_NativeTableType = root::tflite::ModelT;

            #[repr(u16)]
            #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
            pub enum Model_FlatBuffersVTableOffset {
                VT_VERSION = 4,
                VT_OPERATOR_CODES = 6,
                VT_SUBGRAPHS = 8,
                VT_DESCRIPTION = 10,
                VT_BUFFERS = 12,
                VT_METADATA_BUFFER = 14,
                VT_METADATA = 16,
                VT_SIGNATURE_DEFS = 18,
            }

            #[test]
            fn bindgen_test_layout_Model() {
                assert_eq!(
                    ::std::mem::size_of::<Model>(),
                    1usize,
                    concat!("Size of: ", stringify!(Model))
                );
                assert_eq!(
                    ::std::mem::align_of::<Model>(),
                    1usize,
                    concat!("Alignment of ", stringify!(Model))
                );
            }

            #[doc = " Abstract interface that returns TfLiteRegistrations given op codes or custom"]
            #[doc = " op names. This is the mechanism that ops being referenced in the flatbuffer"]
            #[doc = " model are mapped to executable function pointers (TfLiteRegistrations)."]
            #[repr(C)]
            #[repr(align(8))]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct OpResolver {
                pub _bindgen_opaque_blob: u64,
            }

            pub type OpResolver_TfLiteDelegatePtrVector = root::std::vector;

            #[test]
            fn bindgen_test_layout_OpResolver() {
                assert_eq!(
                    ::std::mem::size_of::<OpResolver>(),
                    8usize,
                    concat!("Size of: ", stringify!(OpResolver))
                );
                assert_eq!(
                    ::std::mem::align_of::<OpResolver>(),
                    8usize,
                    concat!("Alignment of ", stringify!(OpResolver))
                );
            }

            #[doc = " An RAII object that represents a read-only tflite model, copied from disk,"]
            #[doc = " or mmapped. This uses flatbuffers as the serialization format."]
            #[doc = ""]
            #[doc = " NOTE: The current API requires that a FlatBufferModel instance be kept alive"]
            #[doc = " by the client as long as it is in use by any dependent Interpreter"]
            #[doc = " instances."]
            #[doc = " <pre><code>"]
            #[doc = " using namespace tflite;"]
            #[doc = " StderrReporter error_reporter;"]
            #[doc = " auto model = FlatBufferModel::BuildFromFile(\"interesting_model.tflite\","]
            #[doc = "                                             &error_reporter);"]
            #[doc = " MyOpResolver resolver;  // You need to subclass OpResolver to provide"]
            #[doc = "                         // implementations."]
            #[doc = " InterpreterBuilder builder(*model, resolver);"]
            #[doc = " std::unique_ptr<Interpreter> interpreter;"]
            #[doc = " if(builder(&interpreter) == kTfLiteOk) {"]
            #[doc = "   .. run model inference with interpreter"]
            #[doc = " }"]
            #[doc = " </code></pre>"]
            #[doc = ""]
            #[doc = " OpResolver must be defined to provide your kernel implementations to the"]
            #[doc = " interpreter. This is environment specific and may consist of just the"]
            #[doc = " builtin ops, or some custom operators you defined to extend tflite."]
            #[repr(C)]
            #[repr(align(8))]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct FlatBufferModel {
                pub _bindgen_opaque_blob: [u64; 3usize],
            }

            #[test]
            fn bindgen_test_layout_FlatBufferModel() {
                assert_eq!(
                    ::std::mem::size_of::<FlatBufferModel>(),
                    24usize,
                    concat!("Size of: ", stringify!(FlatBufferModel))
                );
                assert_eq!(
                    ::std::mem::align_of::<FlatBufferModel>(),
                    8usize,
                    concat!("Alignment of ", stringify!(FlatBufferModel))
                );
            }

            #[doc = " Build an interpreter capable of interpreting `model`."]
            #[doc = ""]
            #[doc = " `model`: A model whose lifetime must be at least as long as any"]
            #[doc = "   interpreter(s) created by the builder. In principle multiple interpreters"]
            #[doc = "   can be made from a single model."]
            #[doc = " `op_resolver`: An instance that implements the `OpResolver` interface, which"]
            #[doc = "   maps custom op names and builtin op codes to op registrations. The"]
            #[doc = "   lifetime of the provided `op_resolver` object must be at least as long as"]
            #[doc = "   the `InterpreterBuilder`; unlike `model` and `error_reporter`, the"]
            #[doc = "   `op_resolver` does not need to exist for the duration of any created"]
            #[doc = "   `Interpreter` objects."]
            #[doc = " `error_reporter`: a functor that is called to report errors that handles"]
            #[doc = "   printf var arg semantics. The lifetime of the `error_reporter` object must"]
            #[doc = "   be greater than or equal to the `Interpreter` created by `operator()`."]
            #[doc = ""]
            #[doc = " Returns a kTfLiteOk when successful and sets interpreter to a valid"]
            #[doc = " Interpreter. Note: The user must ensure the lifetime of the model (and error"]
            #[doc = " reporter, if provided) is at least as long as interpreter's lifetime."]
            #[repr(C)]
            #[repr(align(8))]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct InterpreterBuilder {
                pub _bindgen_opaque_blob: [u64; 14usize],
            }

            #[test]
            fn bindgen_test_layout_InterpreterBuilder() {
                assert_eq!(
                    ::std::mem::size_of::<InterpreterBuilder>(),
                    112usize,
                    concat!("Size of: ", stringify!(InterpreterBuilder))
                );
                assert_eq!(
                    ::std::mem::align_of::<InterpreterBuilder>(),
                    8usize,
                    concat!("Alignment of ", stringify!(InterpreterBuilder))
                );
            }

            pub mod ops {
                #[allow(unused_imports)]
                use self::super::super::super::root;

                pub mod builtin {
                    #[allow(unused_imports)]
                    use self::super::super::super::super::root;

                    #[repr(C)]
                    #[repr(align(8))]
                    #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
                    pub struct BuiltinOpResolver {
                        pub _bindgen_opaque_blob: [u64; 15usize],
                    }

                    #[test]
                    fn bindgen_test_layout_BuiltinOpResolver() {
                        assert_eq!(
                            ::std::mem::size_of::<BuiltinOpResolver>(),
                            120usize,
                            concat!("Size of: ", stringify!(BuiltinOpResolver))
                        );
                        assert_eq!(
                            ::std::mem::align_of::<BuiltinOpResolver>(),
                            8usize,
                            concat!("Alignment of ", stringify!(BuiltinOpResolver))
                        );
                    }
                }
            }
        }

        pub mod flatbuffers {
            #[allow(unused_imports)]
            use self::super::super::root;

            pub type voffset_t = u16;

            #[repr(C)]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct Table {
                pub data_: [u8; 1usize],
            }

            #[test]
            fn bindgen_test_layout_Table() {
                assert_eq!(
                    ::std::mem::size_of::<Table>(),
                    1usize,
                    concat!("Size of: ", stringify!(Table))
                );
                assert_eq!(
                    ::std::mem::align_of::<Table>(),
                    1usize,
                    concat!("Alignment of ", stringify!(Table))
                );
                assert_eq!(
                    unsafe { &(*(::std::ptr::null::<Table>())).data_ as *const _ as usize },
                    0usize,
                    concat!("Offset of field: ", stringify!(Table), "::", stringify!(data_))
                );
            }

            #[repr(C)]
            #[repr(align(1))]
            #[derive(Debug, Default, Copy, Clone, PartialEq, Eq)]
            pub struct NativeTable {
                pub _bindgen_opaque_blob: u8,
            }

            #[test]
            fn bindgen_test_layout_NativeTable() {
                assert_eq!(
                    ::std::mem::size_of::<NativeTable>(),
                    1usize,
                    concat!("Size of: ", stringify!(NativeTable))
                );
                assert_eq!(
                    ::std::mem::align_of::<NativeTable>(),
                    1usize,
                    concat!("Alignment of ", stringify!(NativeTable))
                );
            }
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_TfLiteDelegate__bindgen_ty_id_79129_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                16usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_float_allocator_open1_float_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_float_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_float_allocator_open1_float_close1_close0_instantiation_1(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_float_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_float_allocator_open1_float_close1_close0_instantiation_2(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_float_close0_instantiation_2() {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_int64_t_allocator_open1_long_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_long_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_int32_t_allocator_open1_int_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_int_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_int32_t_allocator_open1_int_close1_close0_instantiation_1(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_unique_ptr_open1_DimensionMetadataT_default_delete_open2_DimensionMetadataT_close2_close1_allocator_open1_unique_ptr_open2_DimensionMetadataT_default_delete_open3_DimensionMetadataT_close3_close2_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_DimensionMetadataT_default_delete_open1_DimensionMetadataT_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                8usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_default_delete_open0_DimensionMetadataT_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::std::default_delete>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::default_delete))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::default_delete>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::default_delete)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_unique_ptr_open1_DimensionMetadataT_default_delete_open2_DimensionMetadataT_close2_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_DimensionMetadataT_default_delete_open1_DimensionMetadataT_close1_close0_instantiation_1(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                8usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_default_delete_open0_DimensionMetadataT_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::std::default_delete>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::default_delete))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::default_delete>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::default_delete)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_int32_t_allocator_open1_int_close1_close0_instantiation_2(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_2() {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_QuantizationParametersT_default_delete_open1_QuantizationParametersT_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                8usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_default_delete_open0_QuantizationParametersT_close0_instantiation()
        {
            assert_eq!(
                ::std::mem::size_of::<root::std::default_delete>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::default_delete))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::default_delete>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::default_delete)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_SparsityParametersT_default_delete_open1_SparsityParametersT_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                8usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_default_delete_open0_SparsityParametersT_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::std::default_delete>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::default_delete))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::default_delete>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::default_delete)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_int32_t_allocator_open1_int_close1_close0_instantiation_3(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_3() {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_int32_t_allocator_open1_int_close1_close0_instantiation_4(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_4() {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_int32_t_allocator_open1_int_close1_close0_instantiation_5(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_5() {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_int32_t_allocator_open1_int_close1_close0_instantiation_6(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_6() {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_int32_t_allocator_open1_int_close1_close0_instantiation_7(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_7() {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_int32_t_allocator_open1_int_close1_close0_instantiation_8(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_8() {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_int32_t_allocator_open1_int_close1_close0_instantiation_9(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_9() {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_uint8_t_allocator_open1_unsigned_char_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_unsigned_char_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_bool__close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_int32_t_allocator_open1_int_close1_close0_instantiation_10(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_10() {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_unique_ptr_open1_TensorT_default_delete_open2_TensorT_close2_close1_allocator_open1_unique_ptr_open2_TensorT_default_delete_open3_TensorT_close3_close2_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_TensorT_default_delete_open1_TensorT_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                8usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_default_delete_open0_TensorT_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::std::default_delete>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::default_delete))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::default_delete>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::default_delete)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_unique_ptr_open1_TensorT_default_delete_open2_TensorT_close2_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_TensorT_default_delete_open1_TensorT_close1_close0_instantiation_1(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                8usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_default_delete_open0_TensorT_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::std::default_delete>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::default_delete))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::default_delete>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::default_delete)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_int32_t_allocator_open1_int_close1_close0_instantiation_11(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_11() {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_int32_t_allocator_open1_int_close1_close0_instantiation_12(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_12() {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_unique_ptr_open1_OperatorT_default_delete_open2_OperatorT_close2_close1_allocator_open1_unique_ptr_open2_OperatorT_default_delete_open3_OperatorT_close3_close2_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_OperatorT_default_delete_open1_OperatorT_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                8usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_default_delete_open0_OperatorT_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::std::default_delete>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::default_delete))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::default_delete>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::default_delete)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_unique_ptr_open1_OperatorT_default_delete_open2_OperatorT_close2_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_OperatorT_default_delete_open1_OperatorT_close1_close0_instantiation_1(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                8usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_default_delete_open0_OperatorT_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::std::default_delete>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::default_delete))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::default_delete>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::default_delete)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_uint8_t_allocator_open1_unsigned_char_close1_close0_instantiation_1(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_unsigned_char_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_unique_ptr_open1_TensorMapT_default_delete_open2_TensorMapT_close2_close1_allocator_open1_unique_ptr_open2_TensorMapT_default_delete_open3_TensorMapT_close3_close2_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_TensorMapT_default_delete_open1_TensorMapT_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                8usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_default_delete_open0_TensorMapT_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::std::default_delete>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::default_delete))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::default_delete>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::default_delete)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_unique_ptr_open1_TensorMapT_default_delete_open2_TensorMapT_close2_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_TensorMapT_default_delete_open1_TensorMapT_close1_close0_instantiation_1(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                8usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_default_delete_open0_TensorMapT_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::std::default_delete>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::default_delete))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::default_delete>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::default_delete)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_unique_ptr_open1_TensorMapT_default_delete_open2_TensorMapT_close2_close1_allocator_open1_unique_ptr_open2_TensorMapT_default_delete_open3_TensorMapT_close3_close2_close1_close0_instantiation_1(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_TensorMapT_default_delete_open1_TensorMapT_close1_close0_instantiation_2(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                8usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_default_delete_open0_TensorMapT_close0_instantiation_2() {
            assert_eq!(
                ::std::mem::size_of::<root::std::default_delete>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::default_delete))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::default_delete>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::default_delete)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_unique_ptr_open1_TensorMapT_default_delete_open2_TensorMapT_close2_close1_close0_instantiation_1(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_TensorMapT_default_delete_open1_TensorMapT_close1_close0_instantiation_3(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                8usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_default_delete_open0_TensorMapT_close0_instantiation_3() {
            assert_eq!(
                ::std::mem::size_of::<root::std::default_delete>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::default_delete))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::default_delete>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::default_delete)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_unique_ptr_open1_OperatorCodeT_default_delete_open2_OperatorCodeT_close2_close1_allocator_open1_unique_ptr_open2_OperatorCodeT_default_delete_open3_OperatorCodeT_close3_close2_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_OperatorCodeT_default_delete_open1_OperatorCodeT_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                8usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_default_delete_open0_OperatorCodeT_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::std::default_delete>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::default_delete))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::default_delete>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::default_delete)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_unique_ptr_open1_OperatorCodeT_default_delete_open2_OperatorCodeT_close2_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_OperatorCodeT_default_delete_open1_OperatorCodeT_close1_close0_instantiation_1(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                8usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_default_delete_open0_OperatorCodeT_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::std::default_delete>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::default_delete))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::default_delete>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::default_delete)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_unique_ptr_open1_SubGraphT_default_delete_open2_SubGraphT_close2_close1_allocator_open1_unique_ptr_open2_SubGraphT_default_delete_open3_SubGraphT_close3_close2_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_SubGraphT_default_delete_open1_SubGraphT_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                8usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_default_delete_open0_SubGraphT_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::std::default_delete>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::default_delete))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::default_delete>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::default_delete)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_unique_ptr_open1_SubGraphT_default_delete_open2_SubGraphT_close2_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_SubGraphT_default_delete_open1_SubGraphT_close1_close0_instantiation_1(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                8usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_default_delete_open0_SubGraphT_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::std::default_delete>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::default_delete))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::default_delete>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::default_delete)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_unique_ptr_open1_BufferT_default_delete_open2_BufferT_close2_close1_allocator_open1_unique_ptr_open2_BufferT_default_delete_open3_BufferT_close3_close2_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_BufferT_default_delete_open1_BufferT_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                8usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_default_delete_open0_BufferT_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::std::default_delete>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::default_delete))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::default_delete>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::default_delete)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_unique_ptr_open1_BufferT_default_delete_open2_BufferT_close2_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_BufferT_default_delete_open1_BufferT_close1_close0_instantiation_1(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                8usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_default_delete_open0_BufferT_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::std::default_delete>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::default_delete))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::default_delete>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::default_delete)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_int32_t_allocator_open1_int_close1_close0_instantiation_13(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_13() {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_unique_ptr_open1_MetadataT_default_delete_open2_MetadataT_close2_close1_allocator_open1_unique_ptr_open2_MetadataT_default_delete_open3_MetadataT_close3_close2_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_MetadataT_default_delete_open1_MetadataT_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                8usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_default_delete_open0_MetadataT_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::std::default_delete>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::default_delete))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::default_delete>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::default_delete)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_unique_ptr_open1_MetadataT_default_delete_open2_MetadataT_close2_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_MetadataT_default_delete_open1_MetadataT_close1_close0_instantiation_1(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                8usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_default_delete_open0_MetadataT_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::std::default_delete>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::default_delete))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::default_delete>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::default_delete)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_unique_ptr_open1_SignatureDefT_default_delete_open2_SignatureDefT_close2_close1_allocator_open1_unique_ptr_open2_SignatureDefT_default_delete_open3_SignatureDefT_close3_close2_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_SignatureDefT_default_delete_open1_SignatureDefT_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                8usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_default_delete_open0_SignatureDefT_close0_instantiation() {
            assert_eq!(
                ::std::mem::size_of::<root::std::default_delete>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::default_delete))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::default_delete>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::default_delete)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_unique_ptr_open1_SignatureDefT_default_delete_open2_SignatureDefT_close2_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_SignatureDefT_default_delete_open1_SignatureDefT_close1_close0_instantiation_1(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                8usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_default_delete_open0_SignatureDefT_close0_instantiation_1() {
            assert_eq!(
                ::std::mem::size_of::<root::std::default_delete>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::default_delete))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::default_delete>(),
                1usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::default_delete)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_vector_open0_unique_ptr_open1_TfLiteDelegate__bindgen_ty_id_90711_close1_allocator_open1_unique_ptr_open2_TfLiteDelegate__bindgen_ty_id_90721_close2_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::vector>(),
                24usize,
                concat!("Size of template specialization: ", stringify!(root::std::vector))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::vector>(),
                8usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::vector))
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_TfLiteDelegate__bindgen_ty_id_90711_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                16usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }

        #[test]
        fn __bindgen_test_layout_allocator_open0_unique_ptr_open1_TfLiteDelegate__bindgen_ty_id_90721_close1_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::allocator>(),
                1usize,
                concat!("Size of template specialization: ", stringify!(root::std::allocator))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::allocator>(),
                1usize,
                concat!("Alignment of template specialization: ", stringify!(root::std::allocator))
            );
        }

        #[test]
        fn __bindgen_test_layout_unique_ptr_open0_TfLiteDelegate__bindgen_ty_id_90721_close0_instantiation(
        ) {
            assert_eq!(
                ::std::mem::size_of::<root::std::unique_ptr>(),
                16usize,
                concat!("Size of template specialization: ", stringify!(root::std::unique_ptr))
            );
            assert_eq!(
                ::std::mem::align_of::<root::std::unique_ptr>(),
                8usize,
                concat!(
                    "Alignment of template specialization: ",
                    stringify!(root::std::unique_ptr)
                )
            );
        }
    }
}
