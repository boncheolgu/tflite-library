#[allow(deprecated)]
impl Default for UniquePtr<{{{rust_type}}}> {
    fn default() -> Self {
        let mut this = mem::MaybeUninit::uninit();
        let this_ref = this.as_mut_ptr();
        unsafe {
            let size = cpp!([this_ref as "std::unique_ptr<{{{cpp_type}}}>*"] -> usize as "size_t" {
                new (this_ref) std::unique_ptr<{{{cpp_type}}}>(new {{{cpp_type}}});
                return sizeof({{{cpp_type}}});
            });
            debug_assert_eq!(mem::size_of::<{{{rust_type}}}>(), size, "{{{rust_type}}} and {{{cpp_type}}} are not equal sizes");
            this.assume_init()
        }
    }
}

#[allow(deprecated)]
impl Deref for UniquePtr<{{{rust_type}}}> {
    type Target = {{{rust_type}}};

    fn deref(&self) -> &Self::Target {
        unsafe {
            let ptr = cpp!([self as "const std::unique_ptr<{{{cpp_type}}}>*"] -> *const {{{rust_type}}} as "const {{{cpp_type}}}*" {
                return self->get();
            }) as *const Self::Target;

            ptr.as_ref().unwrap()
        }
    }
}

#[allow(deprecated)]
impl DerefMut for UniquePtr<{{{rust_type}}}> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        unsafe {
            let ptr = cpp!([self as "std::unique_ptr<{{{cpp_type}}}>*"] -> *mut {{{rust_type}}} as "{{{cpp_type}}}*" {
                return self->get();
            }) as *mut Self::Target;

            ptr.as_mut().unwrap()
        }
    }
}

#[allow(deprecated)]
impl fmt::Debug for UniquePtr<{{{rust_type}}}>
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "({:?})", self.deref())
    }
}

//impl {{{rust_type}}} {
//    #[allow(unused)]
//    fn transmute() {
//        unsafe {
//            let t = mem::MaybeUninit::<Self>::uninit();
//            mem::transmute::<_, {{{rust_original_type}}}>(t);
//        }
//    }
//}